{
    "version": "https://jsonfeed.org/version/1",
    "title": "thehue",
    "home_page_url": "https://thehue.github.io/",
    "feed_url": "https://thehue.github.io/feed.json",
    "description": "Front-end Developer thehue's blog. ",
    "icon": "https://thehue.github.io/apple-touch-icon.png",
    "favicon": "https://thehue.github.io/favicon.ico",
    "expired": false,
    
    "author":  {
        "name": "thehue",
        "url": null,
        "avatar": null
    },
    
"items": [
    
        {
            "id": "https://thehue.github.io/2022/07/01/til-javascript-unit-testing-section3-testing-basics",
            "title": "TIL Udemy Javascript Unit Testing - Section3. Testing Basics",
            "summary": "Testing Basics",
            "content_text": "Basic Test File &amp; Project Setupimport { test } from 'vitest';를 생략하고 싶다면 package.json scripts 속성에 다음과 같이 —globals를 추가한다.The AAA Pattern - Arrange, Act, Assert  Arrange - 테스트 환경 및 값을 정의  Act - 테스트할 실제 코드, 함수를 실행  Assert - 생성된 값과 결과를 평가하고 기대값과 결과를 비교// math.jsexport function add(numbers) {  let sum = 0;  for (const number of numbers) {    sum += number;  }  return sum;}// math.test.jsimport { expect, it } from 'vitest';import { add } from './math';it('should summarize all number values in an array', () =&gt; {  // Arrange  const numbers = [1, 2];  // Act  const result = add(numbers);  // Assert  const expectedResult = numbers.reduce(    (previousValue, currentValue) =&gt; previousValue + currentValue,    0,  );  expect(result).toBe(expectedResult);});Defining Behaviors &amp; Fixing Errors In Your Code  지금 당장 어떤 방식으로 작동 하더라도, 다른 개발자들이 미래에 해당 함수의 코드를 수정한다면 더 이상 예전처럼 작동하지 않을 수도 있기 때문에 가능한 많은 테스트와 기댓값을 정의하는 것이 중요하다.여러가지 상황에 대한 테스트 코드를 작성한다.// math.jsit('should yield NaN if a least one invalid number is provided', () =&gt; {  const inputs = ['invalid', 1];  const result = add(inputs);  expect(result).toBeNaN();});it('should yield a correct sum if an array of numeric string values is provided', () =&gt; {  const numbers = ['1', '2'];  const result = add(numbers);  const expectedResult = numbers.reduce(    (previousValue, currentValue) =&gt; +previousValue + +currentValue,    0,  );  expect(result).toBe(expectedResult);});테스트 코드를 통과시키기 위해서 add 함수를 다음과 같이 수정한다.export function add(numbers) {  let sum = 0;  for (const number of numbers) {    sum += +number;  }  return sum;}Error 테스트 하기it('should throw an error if no value is passed in to the function', () =&gt; {  const resultFn = () =&gt; {    add();  };  expect(resultFn).toThrow();  expect(resultFn).toThrow(/numbers is not iterable/);});Tests With Multiple Assertions (Multiple Expectations)export function transformToNumber(value) {  return +value;}Number 타입으로 변환시켜주는 함수 transformToNumber에 대한 테스트 코드를 다음과 같이 작성할 수 있다.import { it, expect } from 'vitest';it('should transform a string number to a number of type number', () =&gt; {  const input = '1';  const result = transformToNumber(input);  expect(result).toBeTypeOf('number');});it('should yield NaN for non-transformable values', () =&gt; {  const input = 'invalid';  const result = transformToNumber(input);  expect(result).toBeNaN();});하지만 이 코드는 함정이 있다. 만약 transformToNumber 함수가 잘못 구현 되어서 항상 NaN을 return하는 함수라면 테스트 결과가 어떻게 될까?export function transformToNumber(value) {  return NaN;}NaN의 type은 Number이기 때문에 첫 번째 테스트를 통과하게 된다.따라서 실제값을 예측하는 테스트코드를 추가하여 모순을 피한다.non-transformable value를 넣으면 NaN값을 return하는 테스트 케이스에는 다른 케이스도 추가하여 함수의 안정성을 높인다.it('should transform a string number to a number of type number', () =&gt; {  const input = '1';  const result = transformToNumber(input);  **expect(result).toBe(+input);**});it('should yield NaN for non-transformable values', () =&gt; {  const input = 'invalid';  const input2 = {};  const result = transformToNumber(input);  const result2 = transformToNumber(input2);  expect(result).toBeNaN();  expect(result2).toBeNaN();});",
            "content_html": "<h2 id=\"basic-test-file--project-setup\">Basic Test File &amp; Project Setup</h2><div class=\"language-jsx highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">import</span> <span class=\"p\">{</span> <span class=\"nx\">test</span> <span class=\"p\">}</span> <span class=\"k\">from</span> <span class=\"dl\">'</span><span class=\"s1\">vitest</span><span class=\"dl\">'</span><span class=\"p\">;</span></code></pre></div></div><p>를 생략하고 싶다면 package.json scripts 속성에 다음과 같이 <code class=\"language-plaintext highlighter-rouge\">—globals</code>를 추가한다.</p><h2 id=\"the-aaa-pattern---arrange-act-assert\">The AAA Pattern - Arrange, Act, Assert</h2><ul>  <li>Arrange - 테스트 환경 및 값을 정의</li>  <li>Act - 테스트할 실제 코드, 함수를 실행</li>  <li>Assert - 생성된 값과 결과를 평가하고 기대값과 결과를 비교</li></ul><div class=\"language-jsx highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// math.js</span><span class=\"k\">export</span> <span class=\"kd\">function</span> <span class=\"nx\">add</span><span class=\"p\">(</span><span class=\"nx\">numbers</span><span class=\"p\">)</span> <span class=\"p\">{</span>  <span class=\"kd\">let</span> <span class=\"nx\">sum</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>  <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kd\">const</span> <span class=\"nx\">number</span> <span class=\"k\">of</span> <span class=\"nx\">numbers</span><span class=\"p\">)</span> <span class=\"p\">{</span>    <span class=\"nx\">sum</span> <span class=\"o\">+=</span> <span class=\"nx\">number</span><span class=\"p\">;</span>  <span class=\"p\">}</span>  <span class=\"k\">return</span> <span class=\"nx\">sum</span><span class=\"p\">;</span><span class=\"p\">}</span></code></pre></div></div><div class=\"language-jsx highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// math.test.js</span><span class=\"k\">import</span> <span class=\"p\">{</span> <span class=\"nx\">expect</span><span class=\"p\">,</span> <span class=\"nx\">it</span> <span class=\"p\">}</span> <span class=\"k\">from</span> <span class=\"dl\">'</span><span class=\"s1\">vitest</span><span class=\"dl\">'</span><span class=\"p\">;</span><span class=\"k\">import</span> <span class=\"p\">{</span> <span class=\"nx\">add</span> <span class=\"p\">}</span> <span class=\"k\">from</span> <span class=\"dl\">'</span><span class=\"s1\">./math</span><span class=\"dl\">'</span><span class=\"p\">;</span><span class=\"nx\">it</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">should summarize all number values in an array</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"p\">()</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>  <span class=\"c1\">// Arrange</span>  <span class=\"kd\">const</span> <span class=\"nx\">numbers</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">];</span>  <span class=\"c1\">// Act</span>  <span class=\"kd\">const</span> <span class=\"nx\">result</span> <span class=\"o\">=</span> <span class=\"nx\">add</span><span class=\"p\">(</span><span class=\"nx\">numbers</span><span class=\"p\">);</span>  <span class=\"c1\">// Assert</span>  <span class=\"kd\">const</span> <span class=\"nx\">expectedResult</span> <span class=\"o\">=</span> <span class=\"nx\">numbers</span><span class=\"p\">.</span><span class=\"nx\">reduce</span><span class=\"p\">(</span>    <span class=\"p\">(</span><span class=\"nx\">previousValue</span><span class=\"p\">,</span> <span class=\"nx\">currentValue</span><span class=\"p\">)</span> <span class=\"o\">=&gt;</span> <span class=\"nx\">previousValue</span> <span class=\"o\">+</span> <span class=\"nx\">currentValue</span><span class=\"p\">,</span>    <span class=\"mi\">0</span><span class=\"p\">,</span>  <span class=\"p\">);</span>  <span class=\"nx\">expect</span><span class=\"p\">(</span><span class=\"nx\">result</span><span class=\"p\">).</span><span class=\"nx\">toBe</span><span class=\"p\">(</span><span class=\"nx\">expectedResult</span><span class=\"p\">);</span><span class=\"p\">});</span></code></pre></div></div><h2 id=\"defining-behaviors--fixing-errors-in-your-code\">Defining Behaviors &amp; Fixing Errors In Your Code</h2><blockquote>  <p>지금 당장 어떤 방식으로 작동 하더라도, 다른 개발자들이 미래에 해당 함수의 코드를 수정한다면 더 이상 예전처럼 작동하지 않을 수도 있기 때문에 가능한 많은 테스트와 기댓값을 정의하는 것이 중요하다.</p></blockquote><p>여러가지 상황에 대한 테스트 코드를 작성한다.</p><div class=\"language-jsx highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// math.js</span><span class=\"nx\">it</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">should yield NaN if a least one invalid number is provided</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"p\">()</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>  <span class=\"kd\">const</span> <span class=\"nx\">inputs</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"dl\">'</span><span class=\"s1\">invalid</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">];</span>  <span class=\"kd\">const</span> <span class=\"nx\">result</span> <span class=\"o\">=</span> <span class=\"nx\">add</span><span class=\"p\">(</span><span class=\"nx\">inputs</span><span class=\"p\">);</span>  <span class=\"nx\">expect</span><span class=\"p\">(</span><span class=\"nx\">result</span><span class=\"p\">).</span><span class=\"nx\">toBeNaN</span><span class=\"p\">();</span><span class=\"p\">});</span><span class=\"nx\">it</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">should yield a correct sum if an array of numeric string values is provided</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"p\">()</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>  <span class=\"kd\">const</span> <span class=\"nx\">numbers</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"dl\">'</span><span class=\"s1\">1</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"dl\">'</span><span class=\"s1\">2</span><span class=\"dl\">'</span><span class=\"p\">];</span>  <span class=\"kd\">const</span> <span class=\"nx\">result</span> <span class=\"o\">=</span> <span class=\"nx\">add</span><span class=\"p\">(</span><span class=\"nx\">numbers</span><span class=\"p\">);</span>  <span class=\"kd\">const</span> <span class=\"nx\">expectedResult</span> <span class=\"o\">=</span> <span class=\"nx\">numbers</span><span class=\"p\">.</span><span class=\"nx\">reduce</span><span class=\"p\">(</span>    <span class=\"p\">(</span><span class=\"nx\">previousValue</span><span class=\"p\">,</span> <span class=\"nx\">currentValue</span><span class=\"p\">)</span> <span class=\"o\">=&gt;</span> <span class=\"o\">+</span><span class=\"nx\">previousValue</span> <span class=\"o\">+</span> <span class=\"o\">+</span><span class=\"nx\">currentValue</span><span class=\"p\">,</span>    <span class=\"mi\">0</span><span class=\"p\">,</span>  <span class=\"p\">);</span>  <span class=\"nx\">expect</span><span class=\"p\">(</span><span class=\"nx\">result</span><span class=\"p\">).</span><span class=\"nx\">toBe</span><span class=\"p\">(</span><span class=\"nx\">expectedResult</span><span class=\"p\">);</span><span class=\"p\">});</span></code></pre></div></div><p><img src=\"https://user-images.githubusercontent.com/45552388/176831701-d5350037-3c0e-4240-8ca4-d49415a95783.png\" alt=\"failed test results\" /></p><p>테스트 코드를 통과시키기 위해서 <code class=\"language-plaintext highlighter-rouge\">add</code> 함수를 다음과 같이 수정한다.</p><div class=\"language-jsx highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">export</span> <span class=\"kd\">function</span> <span class=\"nx\">add</span><span class=\"p\">(</span><span class=\"nx\">numbers</span><span class=\"p\">)</span> <span class=\"p\">{</span>  <span class=\"kd\">let</span> <span class=\"nx\">sum</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>  <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kd\">const</span> <span class=\"nx\">number</span> <span class=\"k\">of</span> <span class=\"nx\">numbers</span><span class=\"p\">)</span> <span class=\"p\">{</span>    <span class=\"nx\">sum</span> <span class=\"o\">+=</span> <span class=\"o\">+</span><span class=\"nx\">number</span><span class=\"p\">;</span>  <span class=\"p\">}</span>  <span class=\"k\">return</span> <span class=\"nx\">sum</span><span class=\"p\">;</span><span class=\"p\">}</span></code></pre></div></div><h2 id=\"error-테스트-하기\">Error 테스트 하기</h2><div class=\"language-jsx highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nx\">it</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">should throw an error if no value is passed in to the function</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"p\">()</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>  <span class=\"kd\">const</span> <span class=\"nx\">resultFn</span> <span class=\"o\">=</span> <span class=\"p\">()</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>    <span class=\"nx\">add</span><span class=\"p\">();</span>  <span class=\"p\">};</span>  <span class=\"nx\">expect</span><span class=\"p\">(</span><span class=\"nx\">resultFn</span><span class=\"p\">).</span><span class=\"nx\">toThrow</span><span class=\"p\">();</span>  <span class=\"nx\">expect</span><span class=\"p\">(</span><span class=\"nx\">resultFn</span><span class=\"p\">).</span><span class=\"nx\">toThrow</span><span class=\"p\">(</span><span class=\"sr\">/numbers is not iterable/</span><span class=\"p\">);</span><span class=\"p\">});</span></code></pre></div></div><h2 id=\"tests-with-multiple-assertions-multiple-expectations\">Tests With Multiple Assertions (Multiple Expectations)</h2><div class=\"language-jsx highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">export</span> <span class=\"kd\">function</span> <span class=\"nx\">transformToNumber</span><span class=\"p\">(</span><span class=\"nx\">value</span><span class=\"p\">)</span> <span class=\"p\">{</span>  <span class=\"k\">return</span> <span class=\"o\">+</span><span class=\"nx\">value</span><span class=\"p\">;</span><span class=\"p\">}</span></code></pre></div></div><p>Number 타입으로 변환시켜주는 함수 <strong>transformToNumber</strong>에 대한 테스트 코드를 다음과 같이 작성할 수 있다.</p><div class=\"language-jsx highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">import</span> <span class=\"p\">{</span> <span class=\"nx\">it</span><span class=\"p\">,</span> <span class=\"nx\">expect</span> <span class=\"p\">}</span> <span class=\"k\">from</span> <span class=\"dl\">'</span><span class=\"s1\">vitest</span><span class=\"dl\">'</span><span class=\"p\">;</span><span class=\"nx\">it</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">should transform a string number to a number of type number</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"p\">()</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>  <span class=\"kd\">const</span> <span class=\"nx\">input</span> <span class=\"o\">=</span> <span class=\"dl\">'</span><span class=\"s1\">1</span><span class=\"dl\">'</span><span class=\"p\">;</span>  <span class=\"kd\">const</span> <span class=\"nx\">result</span> <span class=\"o\">=</span> <span class=\"nx\">transformToNumber</span><span class=\"p\">(</span><span class=\"nx\">input</span><span class=\"p\">);</span>  <span class=\"nx\">expect</span><span class=\"p\">(</span><span class=\"nx\">result</span><span class=\"p\">).</span><span class=\"nx\">toBeTypeOf</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">number</span><span class=\"dl\">'</span><span class=\"p\">);</span><span class=\"p\">});</span><span class=\"nx\">it</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">should yield NaN for non-transformable values</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"p\">()</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>  <span class=\"kd\">const</span> <span class=\"nx\">input</span> <span class=\"o\">=</span> <span class=\"dl\">'</span><span class=\"s1\">invalid</span><span class=\"dl\">'</span><span class=\"p\">;</span>  <span class=\"kd\">const</span> <span class=\"nx\">result</span> <span class=\"o\">=</span> <span class=\"nx\">transformToNumber</span><span class=\"p\">(</span><span class=\"nx\">input</span><span class=\"p\">);</span>  <span class=\"nx\">expect</span><span class=\"p\">(</span><span class=\"nx\">result</span><span class=\"p\">).</span><span class=\"nx\">toBeNaN</span><span class=\"p\">();</span><span class=\"p\">});</span></code></pre></div></div><p>하지만 이 코드는 함정이 있다. 만약 transformToNumber 함수가 잘못 구현 되어서 항상 NaN을 return하는 함수라면 테스트 결과가 어떻게 될까?</p><div class=\"language-jsx highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">export</span> <span class=\"kd\">function</span> <span class=\"nx\">transformToNumber</span><span class=\"p\">(</span><span class=\"nx\">value</span><span class=\"p\">)</span> <span class=\"p\">{</span>  <span class=\"k\">return</span> <span class=\"kc\">NaN</span><span class=\"p\">;</span><span class=\"p\">}</span></code></pre></div></div><p><img src=\"https://user-images.githubusercontent.com/45552388/176831957-3808e1b4-882a-4740-b0c1-61bf5f6a0338.png\" alt=\"transformToNumber function test\" /></p><p>NaN의 type은 Number이기 때문에 첫 번째 테스트를 통과하게 된다.</p><p>따라서 실제값을 예측하는 테스트코드를 추가하여 모순을 피한다.</p><p>non-transformable value를 넣으면 NaN값을 return하는 테스트 케이스에는 다른 케이스도 추가하여 함수의 안정성을 높인다.</p><div class=\"language-jsx highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nx\">it</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">should transform a string number to a number of type number</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"p\">()</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>  <span class=\"kd\">const</span> <span class=\"nx\">input</span> <span class=\"o\">=</span> <span class=\"dl\">'</span><span class=\"s1\">1</span><span class=\"dl\">'</span><span class=\"p\">;</span>  <span class=\"kd\">const</span> <span class=\"nx\">result</span> <span class=\"o\">=</span> <span class=\"nx\">transformToNumber</span><span class=\"p\">(</span><span class=\"nx\">input</span><span class=\"p\">);</span>  <span class=\"o\">**</span><span class=\"nx\">expect</span><span class=\"p\">(</span><span class=\"nx\">result</span><span class=\"p\">).</span><span class=\"nx\">toBe</span><span class=\"p\">(</span><span class=\"o\">+</span><span class=\"nx\">input</span><span class=\"p\">);</span><span class=\"o\">**</span><span class=\"p\">});</span><span class=\"nx\">it</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">should yield NaN for non-transformable values</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"p\">()</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>  <span class=\"kd\">const</span> <span class=\"nx\">input</span> <span class=\"o\">=</span> <span class=\"dl\">'</span><span class=\"s1\">invalid</span><span class=\"dl\">'</span><span class=\"p\">;</span>  <span class=\"kd\">const</span> <span class=\"nx\">input2</span> <span class=\"o\">=</span> <span class=\"p\">{};</span>  <span class=\"kd\">const</span> <span class=\"nx\">result</span> <span class=\"o\">=</span> <span class=\"nx\">transformToNumber</span><span class=\"p\">(</span><span class=\"nx\">input</span><span class=\"p\">);</span>  <span class=\"kd\">const</span> <span class=\"nx\">result2</span> <span class=\"o\">=</span> <span class=\"nx\">transformToNumber</span><span class=\"p\">(</span><span class=\"nx\">input2</span><span class=\"p\">);</span>  <span class=\"nx\">expect</span><span class=\"p\">(</span><span class=\"nx\">result</span><span class=\"p\">).</span><span class=\"nx\">toBeNaN</span><span class=\"p\">();</span>  <span class=\"nx\">expect</span><span class=\"p\">(</span><span class=\"nx\">result2</span><span class=\"p\">).</span><span class=\"nx\">toBeNaN</span><span class=\"p\">();</span><span class=\"p\">});</span></code></pre></div></div>",
            "url": "https://thehue.github.io/2022/07/01/til-javascript-unit-testing-section3-testing-basics",
            
            
            
            "tags": ["Udemy","TIL","javascript","test","jest","vitest"],
            
            "date_published": "2022-07-01T00:00:00+09:00",
            "date_modified": "2022-07-01T00:00:00+09:00",
            
                "author":  {
                "name": "thehue",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://thehue.github.io/2022/06/08/til-javascript-unit-testing-section2-setup-testing-software",
            "title": "TIL Udemy Javascript Unit Testing - Section2. Setup & Testing Software",
            "summary": "Testing Setup",
            "content_text": "Testing SetupTest Runner(테스트 실행기)  테스트 코드를 실행한다  자동으로 테스트 코드를 감지한다  결과를 보여준다  e.g., Jest, KarmaAssertion Library  예상하는 결과를 정의하는데 사용한다.  예상하는 결과가 맞는지를 체크한다.  모든 종류의 예상 및 모드(sync / async)를 지원한다.  e.g., Jest, ChaiJest vs VitestJest는 페이스북에서 만든 Javascript Testing Framework로 현재 가장 인기가 많은 프레임 워크이다. 그러나 다음과 같은 단점이 있다.  다소 느린 편이다.  commonJS를 사용하는 환경에서 사용하기 어렵다. (babel 설정을 해줘야함)따라서 해당 강의에서는 Vitest를 사용한다. Vitest는 다음과 같은 장점이 있다.  Jest보다 빠르다  Jest 구문과 호환된다.  별도의 설치나 구성 없이 ES modules이나 commonJS를 지원한다.  Jest와 같이 Vitest는 test runner이자 assertion library이다.",
            "content_html": "<h2 id=\"testing-setup\">Testing Setup</h2><p><strong>Test Runner(테스트 실행기)</strong></p><ul>  <li>테스트 코드를 실행한다</li>  <li>자동으로 테스트 코드를 감지한다</li>  <li>결과를 보여준다</li>  <li>e.g., Jest, Karma</li></ul><p><strong>Assertion Library</strong></p><ul>  <li>예상하는 결과를 정의하는데 사용한다.</li>  <li>예상하는 결과가 맞는지를 체크한다.</li>  <li>모든 종류의 예상 및 모드(sync / async)를 지원한다.</li>  <li>e.g., Jest, Chai</li></ul><h3 id=\"jest-vs-vitest\">Jest vs Vitest</h3><p>Jest는 페이스북에서 만든 Javascript Testing Framework로 현재 가장 인기가 많은 프레임 워크이다. 그러나 다음과 같은 단점이 있다.</p><ul>  <li>다소 느린 편이다.</li>  <li>commonJS를 사용하는 환경에서 사용하기 어렵다. (babel 설정을 해줘야함)</li></ul><p>따라서 해당 강의에서는 Vitest를 사용한다. Vitest는 다음과 같은 장점이 있다.</p><ul>  <li>Jest보다 빠르다</li>  <li>Jest 구문과 호환된다.</li>  <li>별도의 설치나 구성 없이 ES modules이나 commonJS를 지원한다.</li>  <li>Jest와 같이 Vitest는 test runner이자 assertion library이다.</li></ul>",
            "url": "https://thehue.github.io/2022/06/08/til-javascript-unit-testing-section2-setup-testing-software",
            
            
            
            "tags": ["Udemy","TIL","javascript","test","jest","vitest"],
            
            "date_published": "2022-06-08T00:00:00+09:00",
            "date_modified": "2022-06-08T00:00:00+09:00",
            
                "author":  {
                "name": "thehue",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://thehue.github.io/2022/06/04/til-javascript-unit-testing-section1-getting-started",
            "title": "TIL Udemy Javascript Unit Testing - Section1. Getting Started",
            "summary": "What is Testing",
            "content_text": "What is Testing  의도한대로 작동 되는지 증명하는 것Manual Testing  지루하고 번거로움  오류가 발생하기 쉬움  종종 불완전함(모든 시나리오가 적용되는 것이 아님)Automated Testing  초기 테스트 코드를 작성하는 것 외엔 따로 신경쓸 것이 없음  예측 가능하고 일관성 있음  높은/완전한 코드 및 시나리오 커버리지 달성 가능함What Are Unit Tests?  앱의 구성 요소  eg., a function, a class, a component          보통은 함수를 unit이라 본다        App = 모든 unit의 조합  모든 unit을 테스트한 경우 전체적인 앱이 작동되어야 한다.          Integration 테스트로 백업한다.        버그를 방지하기 위해 모든 unit에 대해 항상 변경된 사항들을 테스트한다.Why Unit Testing?  끝없는 수동 테스트 방지  코드 및 시나리오의 거의 100%를 커버할 수 있다.  코드가 변경되면 거의 즉시 모든 시나리오들이 테스트된다  메인 코드가 깨끗하고 좋은 방식으로 작성되면 테스트가 더 쉬워지게 때문에 더 나은 코드 작성할 수 있다.Unit, Integration &amp; End-to-End (E2E) Testing 비교Unit Testing  앱의 개별 구성 요소 테스트  모든 unit이 독립적으로 테스트됨  만약 모든 unit들이 작동한다면, 전체 앱이 잘 작동하는 것이다.Integration Testing  units의 조합을 테스트  unit들이 함께 작동하는지 확인한다  모든 unit 테스트가 독립적으로 잘 작동하더라도 통합테스트는 실패할 수 있다.End-to-End(E2E) Testing  전체 흐름 및 애플리케이션 기능을 테스트          애플리케이션이 제공할 수 있는 특정 사용자 행동이나 특정 API 인터페이스에 초점을 맞추고 전체 흐름, 전체 애플리케이션 기능을 테스트한다.        실제 사용자가 수행할 작업을 테스트      예) 이미지 업로드 API EndPoint를 만드는 경우, 들어오는 요청에서 이미지를 추출한 다음 파일 시스템에 저장하는 등의 전체 이미지 업로드 워크플로우를 테스트할 수 있다.          Unit Testing을 사용하면 흐름을 구성하는 개별적인 부분을 테스트할 수 있다      통합 테스트를 통해 이러한 Unit의 조합을 테스트할 수 있다      E2E테스트로 전체 흐름을 테스트할 수 있습니다. 실제 사용자 또는 프로그램과 상호 작용하는 실제 작업을 테스트한다.        모든 종류의 테스트를 결합해서 사용해야 하는 이유          Unit Testing                  파손된 변경 사항 및 오류를 신속하게 찾아내지만 실제 사용자 행동 흐름 및 개입을 무시한다.                    Integration Testing                  정확한 오류의 근원지를 찾는 것이 어려울 수 있다.                    End-to-End(E2E) Testing                  가능한 모든 행동을 커버해서 테스트 하는 것이 어려울 수 있다.                    Test-Driven Development (TDD)테스트를 작성하는 체계 / 철학. 다음의 방식으로 테스트를 작성하는 체계 / 철학이다.      실패하는 테스트를 작성한다.    테스트를 성공시키기 위한 코드를 구현한다.    코드를 리팩토링한다.    1번 과정을 다시 수행한다.  이번 강의는 TDD으로 하진 않는다. 테스트의 기초에 대해서 알아본다.",
            "content_html": "<h2 id=\"what-is-testing\">What is Testing</h2><blockquote>  <p>의도한대로 작동 되는지 증명하는 것</p></blockquote><p><strong>Manual Testing</strong></p><ul>  <li>지루하고 번거로움</li>  <li>오류가 발생하기 쉬움</li>  <li>종종 불완전함(모든 시나리오가 적용되는 것이 아님)</li></ul><p><strong>Automated Testing</strong></p><ul>  <li>초기 테스트 코드를 작성하는 것 외엔 따로 신경쓸 것이 없음</li>  <li>예측 가능하고 일관성 있음</li>  <li>높은/완전한 코드 및 시나리오 커버리지 달성 가능함</li></ul><h2 id=\"what-are-unit-tests\">What Are Unit Tests?</h2><ul>  <li>앱의 구성 요소</li>  <li>eg., a function, a class, a component    <ul>      <li>보통은 함수를 unit이라 본다</li>    </ul>  </li>  <li>App = 모든 unit의 조합</li>  <li>모든 unit을 테스트한 경우 전체적인 앱이 작동되어야 한다.    <ul>      <li>Integration 테스트로 백업한다.</li>    </ul>  </li>  <li>버그를 방지하기 위해 모든 unit에 대해 항상 변경된 사항들을 테스트한다.</li></ul><h2 id=\"why-unit-testing\">Why Unit Testing?</h2><ul>  <li>끝없는 수동 테스트 방지</li>  <li>코드 및 시나리오의 거의 100%를 커버할 수 있다.</li>  <li>코드가 변경되면 거의 즉시 모든 시나리오들이 테스트된다</li>  <li>메인 코드가 깨끗하고 좋은 방식으로 작성되면 테스트가 더 쉬워지게 때문에 더 나은 코드 작성할 수 있다.</li></ul><h2 id=\"unit-integration--end-to-end-e2e-testing-비교\">Unit, Integration &amp; End-to-End (E2E) Testing 비교</h2><p><strong>Unit Testing</strong></p><ul>  <li>앱의 개별 구성 요소 테스트</li>  <li>모든 unit이 독립적으로 테스트됨</li>  <li>만약 모든 unit들이 작동한다면, 전체 앱이 잘 작동하는 것이다.</li></ul><p><strong>Integration Testing</strong></p><ul>  <li>units의 조합을 테스트</li>  <li>unit들이 함께 작동하는지 확인한다</li>  <li>모든 unit 테스트가 독립적으로 잘 작동하더라도 통합테스트는 실패할 수 있다.</li></ul><p><strong>End-to-End(E2E) Testing</strong></p><ul>  <li>전체 흐름 및 애플리케이션 기능을 테스트    <ul>      <li>애플리케이션이 제공할 수 있는 특정 사용자 행동이나 특정 API 인터페이스에 초점을 맞추고 전체 흐름, 전체 애플리케이션 기능을 테스트한다.</li>    </ul>  </li>  <li>실제 사용자가 수행할 작업을 테스트</li>  <li>    <p>예) 이미지 업로드 API <a href=\"https://blog.naver.com/PostView.naver?blogId=ghdalswl77&amp;logNo=222401162545&amp;parentCategoryNo=&amp;categoryNo=90&amp;viewDate=&amp;isShowPopularPosts=true&amp;from=search\">EndPoint</a>를 만드는 경우, 들어오는 요청에서 이미지를 추출한 다음 파일 시스템에 저장하는 등의 전체 이미지 업로드 워크플로우를 테스트할 수 있다.</p>    <ul>      <li>Unit Testing을 사용하면 흐름을 구성하는 개별적인 부분을 테스트할 수 있다</li>      <li>통합 테스트를 통해 이러한 Unit의 조합을 테스트할 수 있다</li>      <li>E2E테스트로 전체 흐름을 테스트할 수 있습니다. 실제 사용자 또는 프로그램과 상호 작용하는 실제 작업을 테스트한다.</li>    </ul>    <p><strong>모든 종류의 테스트를 결합해서 사용해야 하는 이유</strong></p>    <ul>      <li><strong>Unit Testing</strong>        <ul>          <li>파손된 변경 사항 및 오류를 신속하게 찾아내지만 실제 사용자 행동 흐름 및 개입을 무시한다.</li>        </ul>      </li>      <li><strong>Integration Testing</strong>        <ul>          <li>정확한 오류의 근원지를 찾는 것이 어려울 수 있다.</li>        </ul>      </li>      <li><strong>End-to-End(E2E) Testing</strong>        <ul>          <li>가능한 모든 행동을 커버해서 테스트 하는 것이 어려울 수 있다.</li>        </ul>      </li>    </ul>  </li></ul><h2 id=\"test-driven-development-tdd\">Test-Driven Development (TDD)</h2><p>테스트를 작성하는 체계 / 철학. 다음의 방식으로 테스트를 작성하는 체계 / 철학이다.</p><blockquote>  <ol>    <li>실패하는 테스트를 작성한다.</li>    <li>테스트를 성공시키기 위한 코드를 구현한다.</li>    <li>코드를 리팩토링한다.</li>    <li>1번 과정을 다시 수행한다.</li>  </ol></blockquote><p>이번 강의는 TDD으로 하진 않는다. 테스트의 기초에 대해서 알아본다.</p>",
            "url": "https://thehue.github.io/2022/06/04/til-javascript-unit-testing-section1-getting-started",
            
            
            
            "tags": ["Udemy","TIL","javascript","test"],
            
            "date_published": "2022-06-04T00:00:00+09:00",
            "date_modified": "2022-06-04T00:00:00+09:00",
            
                "author":  {
                "name": "thehue",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://thehue.github.io/2022/05/10/til-%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C-10%EC%9E%A5-%ED%81%B4%EB%9E%98%EC%8A%A4",
            "title": "TIL 클린코드 - 10장. 클래스",
            "summary": "책 클린코드 10장 깨끗한 클래스에 대해 알려준다.",
            "content_text": "TIL (Today I Learned)2022.05.10오늘 읽은 범위10장. 클래스책에서 기억하고 싶은 내용을 써보세요.  클래스 체계          변수 목록 → 함수      클래스를 정의하는 표준 자바 관계에 따르면 다음 순서를 따른다.                  static public          static private          private 인스턴스 변수          public 함수          private 함수는 자신을 호출하는 공개 함수 직후에 넣는다.                    캡슐화 - 변수와 유틸리티 함수는 가능한 공개하지 않는 편이 낫지만 반드시 숨겨야 한다는 법칙도 없다. 때로는 변수나 유틸리티 함수를 protected로 선언해 테스트 코드에 접근을 허용하기도 한다. 하지만 캡슐화를 풀어주는 결정은 언제나 최후의 수단이다.        클래스는 작아야 한다!          함수는 물리적인 행 수로 크기를 측정했다. 클래스는 맡은 책임을 세는 것을 척도로 여긴다.      클래스 이름은 해당 클래스 책임을 기술해야 한다. 간결한 이름이 떠오르지 않는다면 필경 클래스 크기가 너무 커서 그렇다.      클래스 설명은 if, and, or, but을 사용하지 않고서 25단어 내외로 가능해야 한다.      단일 책임 원칙 (SRP) - 단일 책임 원칙은 클래스나 모듈을 변경할 이유가 하나, 단 하나뿐이어야 한다는 원칙이다.      책임, 즉 변경할 이유를 파악하려 애쓰다 보면 코드를 추상화하기도 쉬워진다.                  SuperDashboard에서 버전 정보를 다루는 메서드 세 개를 따로 빼내 Version이라는 독자적인 클래스를 만든다.            public class Version {  public int getMajorVersionNumber()  public int getMinorVersionNumber()  public int getBuildNumber()}                                          큼직한 다목적 클래스 몇 개로 이뤄진 시스템은 당장 알 필요가 없는 사실까지 들이밀어 독자를 방해한다.      응집도 - 클래스는 인스턴스 변수 수가 작아야한다. 각 클래스 메서드는 클래스 인스턴스 변수를 하나 이상 사용해야 한다.      ‘함수를 작게, 매개변수 목록을 짧게’라는 전략을 따르다 보면 때때로 몇몇 메서드만이 사용하는 인스턴스 변수가 아주 많아진다. 이는 십중팔구 새로운 클래스로 쪼개야 한다는 신호다. 응집도가 높아지도록 변수와 메서드를 적절히 분리해 새로운 클래스 두세 개로 쪼개준다.        변경하기 쉬운 클래스          깨끗한 시스템은 클래스를 체계적으로 정리해 변경에 수반하는 위험을 낮춘다.      오늘 읽은 소감은? 떠오르는 생각을 가볍게 적어보세요  어떻게 클래스를 책임에 따라 분리 하는지, 클래스명을 어떤식으로 수정 하는지를 중심으로 봤다. 해당 방법을 타입스크립트로 클래스를 설계할 일이 있다면 참고하면 좋을 것 같다.더 공부한 내용출처: Clean Code concepts adapted for JavaScript - 한글 번역판SOLID단일 책임 원칙 (Single Responsibility Principle, SRP)하나의 클래스에 많은 기능을 쑤셔 넣으면 안된다. 하나의 클래스에 너무 많은 기능들이 있고 당신이 이 작은 기능들을 수정할 때 이 코드가 다른 모듈들에 어떠한 영향을 끼치는지 이해하기 어려울 수 있기 때문이다.안 좋은 예:class UserSettings {  constructor(user) {    this.user = user;  }  changeSettings(settings) {    if (this.verifyCredentials()) {      // ...    }  }  verifyCredentials() {    // ...  }}좋은 예:class UserAuth {  constructor(user) {    this.user = user;  }  verifyCredentials() {    // ...  }}class UserSettings {  constructor(user) {    this.user = user;    this.auth = new UserAuth(user);  }  changeSettings(settings) {    if (this.auth.verifyCredentials()) {      // ...    }  }}개방/폐쇄 원칙 (Open/Closed Principle, OCP)이 원리는 기본적으로 사용자가 .js소스 코드 파일을 열어 수동으로 조작하지 않고도 모듈의 기능을 확장하도록 허용해야한다고 말한다.안 좋은 예:class AjaxAdapter extends Adapter {  constructor() {    super();    this.name = 'ajaxAdapter';  }}class NodeAdapter extends Adapter {  constructor() {    super();    this.name = 'nodeAdapter';  }}class HttpRequester {  constructor(adapter) {    this.adapter = adapter;  }  fetch(url) {    if (this.adapter.name === 'ajaxAdapter') {      return makeAjaxCall(url).then((response) =&gt; {        // transform response and return      });    } else if (this.adapter.name === 'httpNodeAdapter') {      return makeHttpCall(url).then((response) =&gt; {        // transform response and return      });    }  }}function makeAjaxCall(url) {  // request and return promise}function makeHttpCall(url) {  // request and return promise}좋은 예:class AjaxAdapter extends Adapter {  constructor() {    super();    this.name = 'ajaxAdapter';  }  request(url) {    // request and return promise  }}class NodeAdapter extends Adapter {  constructor() {    super();    this.name = 'nodeAdapter';  }  request(url) {    // request and return promise  }}// 각 adapter마다 커스텀으로 requestUrl 처리가 가능함.class HttpRequester {  constructor(adapter) {    this.adapter = adapter;  }  fetch(url) {    return this.adapter.request(url).then((response) =&gt; {      // transform response and return    });  }}리스코프 치환 원칙 (Liskov Substitution Principle, LSP)리스코프 치환 원칙이란 자료형 S가 자료형 T의 하위형이면 프로그램이 갖추어야 할 속성들의 변경사항 없이, 자료형 T의 객체를 자료형 S의 객체로 교체할 수 있어야 한다는 원칙이다.안좋은 예:class Rectangle {  constructor() {    this.width = 0;    this.height = 0;  }  setColor(color) {    // ...  }  render(area) {    // ...  }  setWidth(width) {    this.width = width;  }  setHeight(height) {    this.height = height;  }  getArea() {    return this.width * this.height;  }}// 정사각형class Square extends Rectangle {  setWidth(width) {    this.width = width;    this.height = width;  }  setHeight(height) {    this.width = height;    this.height = height;  }}function renderLargeRectangles(rectangles) {  rectangles.forEach((rectangle) =&gt; {    rectangle.setWidth(4);    rectangle.setHeight(5);    const area = rectangle.getArea(); // 정사각형일때 25를 리턴합니다. 하지만 20이어야 하는게 맞습니다.    rectangle.render(area);  });}const rectangles = [new Rectangle(), new Rectangle(), new Square()];renderLargeRectangles(rectangles);좋은 예:class Shape {  setColor(color) {    // ...  }  render(area) {    // ...  }}class Rectangle extends Shape {  constructor(width, height) {    super();    this.width = width;    this.height = height;  }  getArea() {    return this.width * this.height;  }}class Square extends Shape {  constructor(length) {    super();    this.length = length;  }  getArea() {    return this.length * this.length;  }}function renderLargeShapes(shapes) {  shapes.forEach((shape) =&gt; {    const area = shape.getArea();    shape.render(area);  });}const shapes = [new Rectangle(4, 5), new Rectangle(4, 5), new Square(5)];renderLargeShapes(shapes);인터페이스 분리 원칙(Interface Segregation Principle, ISP)  Javascript에 타입 시스템이 없다 하더라도 중요하고 관계있는 원칙  ISP에 의하면 클라이언트는 사용하지 않는 인터페이스에 의존하도록 강요받으면 안된다. 덕 타이핑 때문에 인터페이스는 Javascript에서는 암시적인 계약일 뿐이다.  설정을 선택적으로 할 수 있다면 무거운 인터페이스를 만드는 것을 방지 할 수 있다.안좋은 예class DOMTraverser {  constructor(settings) {    this.settings = settings;    this.setup();  }  setup() {    this.rootNode = this.settings.rootNode;    this.animationModule.setup();  }  traverse() {    // ...  }}const $ = new DOMTraverser({  rootNode: document.getElementsByTagName('body'),  animationModule() {}, // 우리는 대부분의 경우 DOM을 탐색할 때 애니메이션이 필요하지 않습니다.  // ...});좋은 예class DOMTraverser {  constructor(settings) {    this.settings = settings;    this.options = settings.options;    this.setup();  }  setup() {    this.rootNode = this.settings.rootNode;    this.setupOptions();  }  setupOptions() {    if (this.options.animationModule) {      // ...    }  }  traverse() {    // ...  }}const $ = new DOMTraverser({  rootNode: document.getElementsByTagName('body'),  options: {    animationModule() {},  },});의존성 역전 원칙 (Dependency Inversion Principle, DIP)  상위 모듈은 하위 모듈에 종속 되어서는 안된다. 둘 다 추상화에 의존해야 한다.  추상화는 세부사항에 의존하지 않는다. 세부사항은 추상화에 의해 달라져야 한다.DI의 장점은 모듈 간의 의존성을 감소시키는 데에 있다. 모듈간의 의존성이 높을수록 코드를 리팩토링 하는데 어려워진다.Javascript에는 인터페이스가 없으므로 추상화에 의존하는 것은 암시적인 약속이다. 즉 다른 객체나 클래스에 노출되는 메소드와 속성이 바로 암시적인 약속(추상화)가 된다는 것이다.아래 예제에서 암시적인 약속은 InventoryTracker에 대한 모든 요청 모듈이 requestItems 메소드를 가질 것이라는 점이다.안좋은 예:class InventoryRequester {  constructor() {    this.REQ_METHODS = ['HTTP'];  }  requestItem(item) {    // ...  }}class InventoryTracker {  constructor(items) {    this.items = items;    // 안좋은 이유: 특정 요청방법 구현에 대한 의존성을 만들었습니다.    // requestItems는 한가지 요청방법을 필요로 합니다.    this.requester = new InventoryRequester();  }  requestItems() {    this.items.forEach((item) =&gt; {      this.requester.requestItem(item);    });  }}const inventoryTracker = new InventoryTracker(['apples', 'bananas']);inventoryTracker.requestItems();좋은 예:class InventoryTracker {  constructor(items, requester) {    this.items = items;    this.requester = requester;  }  requestItems() {    this.items.forEach((item) =&gt; {      this.requester.requestItem(item);    });  }}class InventoryRequesterV1 {  constructor() {    this.REQ_METHODS = ['HTTP'];  }  requestItem(item) {    // ...  }}class InventoryRequesterV2 {  constructor() {    this.REQ_METHODS = ['WS'];  }  requestItem(item) {    // ...  }}// 의존성을 외부에서 만들어 주입해줌으로써,// 요청 모듈을 새롭게 만든 웹소켓 사용 모듈로 쉽게 바꿔 끼울 수 있게 되었습니다.const inventoryTracker = new InventoryTracker(  ['apples', 'bananas'],  new InventoryRequesterV2(),);inventoryTracker.requestItems();",
            "content_html": "<h2 id=\"til-today-i-learned\"><strong>TIL (Today I Learned)</strong></h2><p>2022.05.10</p><h2 id=\"오늘-읽은-범위\"><strong>오늘 읽은 범위</strong></h2><p>10장. 클래스</p><h2 id=\"책에서-기억하고-싶은-내용을-써보세요\"><strong>책에서 기억하고 싶은 내용을 써보세요.</strong></h2><ul>  <li>클래스 체계    <ul>      <li>변수 목록 → 함수</li>      <li>클래스를 정의하는 표준 자바 관계에 따르면 다음 순서를 따른다.        <ol>          <li>static public</li>          <li>static private</li>          <li>private 인스턴스 변수</li>          <li>public 함수</li>          <li>private 함수는 자신을 호출하는 공개 함수 직후에 넣는다.</li>        </ol>      </li>      <li>캡슐화 - 변수와 유틸리티 함수는 가능한 공개하지 않는 편이 낫지만 반드시 숨겨야 한다는 법칙도 없다. 때로는 변수나 유틸리티 함수를 protected로 선언해 테스트 코드에 접근을 허용하기도 한다. 하지만 캡슐화를 풀어주는 결정은 언제나 최후의 수단이다.</li>    </ul>  </li>  <li>클래스는 작아야 한다!    <ul>      <li>함수는 물리적인 행 수로 크기를 측정했다. 클래스는 맡은 <code class=\"language-plaintext highlighter-rouge\">책임</code>을 세는 것을 척도로 여긴다.</li>      <li>클래스 이름은 해당 클래스 책임을 기술해야 한다. 간결한 이름이 떠오르지 않는다면 필경 클래스 크기가 너무 커서 그렇다.</li>      <li>클래스 설명은 if, and, or, but을 사용하지 않고서 25단어 내외로 가능해야 한다.</li>      <li><code class=\"language-plaintext highlighter-rouge\">단일 책임 원칙 (SRP)</code> - 단일 책임 원칙은 클래스나 모듈을 변경할 이유가 하나, 단 하나뿐이어야 한다는 원칙이다.</li>      <li>책임, 즉 변경할 이유를 파악하려 애쓰다 보면 코드를 추상화하기도 쉬워진다.        <ul>          <li>SuperDashboard에서 버전 정보를 다루는 메서드 세 개를 따로 빼내 Version이라는 독자적인 클래스를 만든다.            <div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Version</span> <span class=\"o\">{</span>  <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">getMajorVersionNumber</span><span class=\"o\">()</span>  <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">getMinorVersionNumber</span><span class=\"o\">()</span>  <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">getBuildNumber</span><span class=\"o\">()</span><span class=\"o\">}</span></code></pre></div>            </div>          </li>        </ul>      </li>      <li>큼직한 다목적 클래스 몇 개로 이뤄진 시스템은 당장 알 필요가 없는 사실까지 들이밀어 독자를 방해한다.</li>      <li><code class=\"language-plaintext highlighter-rouge\">응집도</code> - 클래스는 인스턴스 변수 수가 작아야한다. 각 클래스 메서드는 클래스 인스턴스 변수를 하나 이상 사용해야 한다.</li>      <li>‘함수를 작게, 매개변수 목록을 짧게’라는 전략을 따르다 보면 때때로 몇몇 메서드만이 사용하는 인스턴스 변수가 아주 많아진다. 이는 십중팔구 새로운 클래스로 쪼개야 한다는 신호다. 응집도가 높아지도록 변수와 메서드를 적절히 분리해 새로운 클래스 두세 개로 쪼개준다.</li>    </ul>  </li>  <li>변경하기 쉬운 클래스    <ul>      <li>깨끗한 시스템은 클래스를 체계적으로 정리해 변경에 수반하는 위험을 낮춘다.</li>    </ul>  </li></ul><h2 id=\"오늘-읽은-소감은-떠오르는-생각을-가볍게-적어보세요\"><strong>오늘 읽은 소감은? 떠오르는 생각을 가볍게 적어보세요</strong></h2><ul>  <li>어떻게 클래스를 책임에 따라 분리 하는지, 클래스명을 어떤식으로 수정 하는지를 중심으로 봤다. 해당 방법을 타입스크립트로 클래스를 설계할 일이 있다면 참고하면 좋을 것 같다.</li></ul><h2 id=\"더-공부한-내용\"><strong>더 공부한 내용</strong></h2><p>출처: <a href=\"https://github.com/qkraudghgh/clean-code-javascript-ko\">Clean Code concepts adapted for JavaScript - 한글 번역판</a></p><h3 id=\"solid\"><a href=\"https://ko.wikipedia.org/wiki/SOLID_(%EA%B0%9D%EC%B2%B4_%EC%A7%80%ED%96%A5_%EC%84%A4%EA%B3%84)\">SOLID</a></h3><hr /><h3 id=\"단일-책임-원칙-single-responsibility-principle-srp\">단일 책임 원칙 (Single Responsibility Principle, SRP)</h3><p>하나의 클래스에 많은 기능을 쑤셔 넣으면 안된다. 하나의 클래스에 너무 많은 기능들이 있고 당신이 이 작은 기능들을 수정할 때 이 코드가 다른 모듈들에 어떠한 영향을 끼치는지 이해하기 어려울 수 있기 때문이다.</p><p>안 좋은 예:</p><div class=\"language-jsx highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nx\">UserSettings</span> <span class=\"p\">{</span>  <span class=\"kd\">constructor</span><span class=\"p\">(</span><span class=\"nx\">user</span><span class=\"p\">)</span> <span class=\"p\">{</span>    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">user</span> <span class=\"o\">=</span> <span class=\"nx\">user</span><span class=\"p\">;</span>  <span class=\"p\">}</span>  <span class=\"nx\">changeSettings</span><span class=\"p\">(</span><span class=\"nx\">settings</span><span class=\"p\">)</span> <span class=\"p\">{</span>    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">verifyCredentials</span><span class=\"p\">())</span> <span class=\"p\">{</span>      <span class=\"c1\">// ...</span>    <span class=\"p\">}</span>  <span class=\"p\">}</span>  <span class=\"nx\">verifyCredentials</span><span class=\"p\">()</span> <span class=\"p\">{</span>    <span class=\"c1\">// ...</span>  <span class=\"p\">}</span><span class=\"p\">}</span></code></pre></div></div><p>좋은 예:</p><div class=\"language-jsx highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nx\">UserAuth</span> <span class=\"p\">{</span>  <span class=\"kd\">constructor</span><span class=\"p\">(</span><span class=\"nx\">user</span><span class=\"p\">)</span> <span class=\"p\">{</span>    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">user</span> <span class=\"o\">=</span> <span class=\"nx\">user</span><span class=\"p\">;</span>  <span class=\"p\">}</span>  <span class=\"nx\">verifyCredentials</span><span class=\"p\">()</span> <span class=\"p\">{</span>    <span class=\"c1\">// ...</span>  <span class=\"p\">}</span><span class=\"p\">}</span><span class=\"kd\">class</span> <span class=\"nx\">UserSettings</span> <span class=\"p\">{</span>  <span class=\"kd\">constructor</span><span class=\"p\">(</span><span class=\"nx\">user</span><span class=\"p\">)</span> <span class=\"p\">{</span>    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">user</span> <span class=\"o\">=</span> <span class=\"nx\">user</span><span class=\"p\">;</span>    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">auth</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">UserAuth</span><span class=\"p\">(</span><span class=\"nx\">user</span><span class=\"p\">);</span>  <span class=\"p\">}</span>  <span class=\"nx\">changeSettings</span><span class=\"p\">(</span><span class=\"nx\">settings</span><span class=\"p\">)</span> <span class=\"p\">{</span>    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">auth</span><span class=\"p\">.</span><span class=\"nx\">verifyCredentials</span><span class=\"p\">())</span> <span class=\"p\">{</span>      <span class=\"c1\">// ...</span>    <span class=\"p\">}</span>  <span class=\"p\">}</span><span class=\"p\">}</span></code></pre></div></div><h3 id=\"개방폐쇄-원칙-openclosed-principle-ocp\">개방/폐쇄 원칙 (Open/Closed Principle, OCP)</h3><p>이 원리는 기본적으로 사용자가 <code class=\"language-plaintext highlighter-rouge\">.js</code>소스 코드 파일을 열어 수동으로 조작하지 않고도 모듈의 기능을 확장하도록 허용해야한다고 말한다.</p><p>안 좋은 예:</p><div class=\"language-jsx highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nx\">AjaxAdapter</span> <span class=\"kd\">extends</span> <span class=\"nx\">Adapter</span> <span class=\"p\">{</span>  <span class=\"kd\">constructor</span><span class=\"p\">()</span> <span class=\"p\">{</span>    <span class=\"k\">super</span><span class=\"p\">();</span>    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">name</span> <span class=\"o\">=</span> <span class=\"dl\">'</span><span class=\"s1\">ajaxAdapter</span><span class=\"dl\">'</span><span class=\"p\">;</span>  <span class=\"p\">}</span><span class=\"p\">}</span><span class=\"kd\">class</span> <span class=\"nx\">NodeAdapter</span> <span class=\"kd\">extends</span> <span class=\"nx\">Adapter</span> <span class=\"p\">{</span>  <span class=\"kd\">constructor</span><span class=\"p\">()</span> <span class=\"p\">{</span>    <span class=\"k\">super</span><span class=\"p\">();</span>    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">name</span> <span class=\"o\">=</span> <span class=\"dl\">'</span><span class=\"s1\">nodeAdapter</span><span class=\"dl\">'</span><span class=\"p\">;</span>  <span class=\"p\">}</span><span class=\"p\">}</span><span class=\"kd\">class</span> <span class=\"nx\">HttpRequester</span> <span class=\"p\">{</span>  <span class=\"kd\">constructor</span><span class=\"p\">(</span><span class=\"nx\">adapter</span><span class=\"p\">)</span> <span class=\"p\">{</span>    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">adapter</span> <span class=\"o\">=</span> <span class=\"nx\">adapter</span><span class=\"p\">;</span>  <span class=\"p\">}</span>  <span class=\"nx\">fetch</span><span class=\"p\">(</span><span class=\"nx\">url</span><span class=\"p\">)</span> <span class=\"p\">{</span>    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">adapter</span><span class=\"p\">.</span><span class=\"nx\">name</span> <span class=\"o\">===</span> <span class=\"dl\">'</span><span class=\"s1\">ajaxAdapter</span><span class=\"dl\">'</span><span class=\"p\">)</span> <span class=\"p\">{</span>      <span class=\"k\">return</span> <span class=\"nx\">makeAjaxCall</span><span class=\"p\">(</span><span class=\"nx\">url</span><span class=\"p\">).</span><span class=\"nx\">then</span><span class=\"p\">((</span><span class=\"nx\">response</span><span class=\"p\">)</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>        <span class=\"c1\">// transform response and return</span>      <span class=\"p\">});</span>    <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">adapter</span><span class=\"p\">.</span><span class=\"nx\">name</span> <span class=\"o\">===</span> <span class=\"dl\">'</span><span class=\"s1\">httpNodeAdapter</span><span class=\"dl\">'</span><span class=\"p\">)</span> <span class=\"p\">{</span>      <span class=\"k\">return</span> <span class=\"nx\">makeHttpCall</span><span class=\"p\">(</span><span class=\"nx\">url</span><span class=\"p\">).</span><span class=\"nx\">then</span><span class=\"p\">((</span><span class=\"nx\">response</span><span class=\"p\">)</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>        <span class=\"c1\">// transform response and return</span>      <span class=\"p\">});</span>    <span class=\"p\">}</span>  <span class=\"p\">}</span><span class=\"p\">}</span><span class=\"kd\">function</span> <span class=\"nx\">makeAjaxCall</span><span class=\"p\">(</span><span class=\"nx\">url</span><span class=\"p\">)</span> <span class=\"p\">{</span>  <span class=\"c1\">// request and return promise</span><span class=\"p\">}</span><span class=\"kd\">function</span> <span class=\"nx\">makeHttpCall</span><span class=\"p\">(</span><span class=\"nx\">url</span><span class=\"p\">)</span> <span class=\"p\">{</span>  <span class=\"c1\">// request and return promise</span><span class=\"p\">}</span></code></pre></div></div><p>좋은 예:</p><div class=\"language-jsx highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nx\">AjaxAdapter</span> <span class=\"kd\">extends</span> <span class=\"nx\">Adapter</span> <span class=\"p\">{</span>  <span class=\"kd\">constructor</span><span class=\"p\">()</span> <span class=\"p\">{</span>    <span class=\"k\">super</span><span class=\"p\">();</span>    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">name</span> <span class=\"o\">=</span> <span class=\"dl\">'</span><span class=\"s1\">ajaxAdapter</span><span class=\"dl\">'</span><span class=\"p\">;</span>  <span class=\"p\">}</span>  <span class=\"nx\">request</span><span class=\"p\">(</span><span class=\"nx\">url</span><span class=\"p\">)</span> <span class=\"p\">{</span>    <span class=\"c1\">// request and return promise</span>  <span class=\"p\">}</span><span class=\"p\">}</span><span class=\"kd\">class</span> <span class=\"nx\">NodeAdapter</span> <span class=\"kd\">extends</span> <span class=\"nx\">Adapter</span> <span class=\"p\">{</span>  <span class=\"kd\">constructor</span><span class=\"p\">()</span> <span class=\"p\">{</span>    <span class=\"k\">super</span><span class=\"p\">();</span>    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">name</span> <span class=\"o\">=</span> <span class=\"dl\">'</span><span class=\"s1\">nodeAdapter</span><span class=\"dl\">'</span><span class=\"p\">;</span>  <span class=\"p\">}</span>  <span class=\"nx\">request</span><span class=\"p\">(</span><span class=\"nx\">url</span><span class=\"p\">)</span> <span class=\"p\">{</span>    <span class=\"c1\">// request and return promise</span>  <span class=\"p\">}</span><span class=\"p\">}</span><span class=\"c1\">// 각 adapter마다 커스텀으로 requestUrl 처리가 가능함.</span><span class=\"kd\">class</span> <span class=\"nx\">HttpRequester</span> <span class=\"p\">{</span>  <span class=\"kd\">constructor</span><span class=\"p\">(</span><span class=\"nx\">adapter</span><span class=\"p\">)</span> <span class=\"p\">{</span>    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">adapter</span> <span class=\"o\">=</span> <span class=\"nx\">adapter</span><span class=\"p\">;</span>  <span class=\"p\">}</span>  <span class=\"nx\">fetch</span><span class=\"p\">(</span><span class=\"nx\">url</span><span class=\"p\">)</span> <span class=\"p\">{</span>    <span class=\"k\">return</span> <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">adapter</span><span class=\"p\">.</span><span class=\"nx\">request</span><span class=\"p\">(</span><span class=\"nx\">url</span><span class=\"p\">).</span><span class=\"nx\">then</span><span class=\"p\">((</span><span class=\"nx\">response</span><span class=\"p\">)</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>      <span class=\"c1\">// transform response and return</span>    <span class=\"p\">});</span>  <span class=\"p\">}</span><span class=\"p\">}</span></code></pre></div></div><h3 id=\"리스코프-치환-원칙-liskov-substitution-principle-lsp\">리스코프 치환 원칙 (Liskov Substitution Principle, LSP)</h3><p>리스코프 치환 원칙이란 자료형 S가 자료형 T의 하위형이면 프로그램이 갖추어야 할 속성들의 변경사항 없이, 자료형 T의 객체를 자료형 S의 객체로 교체할 수 있어야 한다는 원칙이다.</p><p>안좋은 예:</p><div class=\"language-jsx highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nx\">Rectangle</span> <span class=\"p\">{</span>  <span class=\"kd\">constructor</span><span class=\"p\">()</span> <span class=\"p\">{</span>    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">width</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">height</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>  <span class=\"p\">}</span>  <span class=\"nx\">setColor</span><span class=\"p\">(</span><span class=\"nx\">color</span><span class=\"p\">)</span> <span class=\"p\">{</span>    <span class=\"c1\">// ...</span>  <span class=\"p\">}</span>  <span class=\"nx\">render</span><span class=\"p\">(</span><span class=\"nx\">area</span><span class=\"p\">)</span> <span class=\"p\">{</span>    <span class=\"c1\">// ...</span>  <span class=\"p\">}</span>  <span class=\"nx\">setWidth</span><span class=\"p\">(</span><span class=\"nx\">width</span><span class=\"p\">)</span> <span class=\"p\">{</span>    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">width</span> <span class=\"o\">=</span> <span class=\"nx\">width</span><span class=\"p\">;</span>  <span class=\"p\">}</span>  <span class=\"nx\">setHeight</span><span class=\"p\">(</span><span class=\"nx\">height</span><span class=\"p\">)</span> <span class=\"p\">{</span>    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">height</span> <span class=\"o\">=</span> <span class=\"nx\">height</span><span class=\"p\">;</span>  <span class=\"p\">}</span>  <span class=\"nx\">getArea</span><span class=\"p\">()</span> <span class=\"p\">{</span>    <span class=\"k\">return</span> <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">width</span> <span class=\"o\">*</span> <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">height</span><span class=\"p\">;</span>  <span class=\"p\">}</span><span class=\"p\">}</span><span class=\"c1\">// 정사각형</span><span class=\"kd\">class</span> <span class=\"nx\">Square</span> <span class=\"kd\">extends</span> <span class=\"nx\">Rectangle</span> <span class=\"p\">{</span>  <span class=\"nx\">setWidth</span><span class=\"p\">(</span><span class=\"nx\">width</span><span class=\"p\">)</span> <span class=\"p\">{</span>    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">width</span> <span class=\"o\">=</span> <span class=\"nx\">width</span><span class=\"p\">;</span>    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">height</span> <span class=\"o\">=</span> <span class=\"nx\">width</span><span class=\"p\">;</span>  <span class=\"p\">}</span>  <span class=\"nx\">setHeight</span><span class=\"p\">(</span><span class=\"nx\">height</span><span class=\"p\">)</span> <span class=\"p\">{</span>    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">width</span> <span class=\"o\">=</span> <span class=\"nx\">height</span><span class=\"p\">;</span>    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">height</span> <span class=\"o\">=</span> <span class=\"nx\">height</span><span class=\"p\">;</span>  <span class=\"p\">}</span><span class=\"p\">}</span><span class=\"kd\">function</span> <span class=\"nx\">renderLargeRectangles</span><span class=\"p\">(</span><span class=\"nx\">rectangles</span><span class=\"p\">)</span> <span class=\"p\">{</span>  <span class=\"nx\">rectangles</span><span class=\"p\">.</span><span class=\"nx\">forEach</span><span class=\"p\">((</span><span class=\"nx\">rectangle</span><span class=\"p\">)</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>    <span class=\"nx\">rectangle</span><span class=\"p\">.</span><span class=\"nx\">setWidth</span><span class=\"p\">(</span><span class=\"mi\">4</span><span class=\"p\">);</span>    <span class=\"nx\">rectangle</span><span class=\"p\">.</span><span class=\"nx\">setHeight</span><span class=\"p\">(</span><span class=\"mi\">5</span><span class=\"p\">);</span>    <span class=\"kd\">const</span> <span class=\"nx\">area</span> <span class=\"o\">=</span> <span class=\"nx\">rectangle</span><span class=\"p\">.</span><span class=\"nx\">getArea</span><span class=\"p\">();</span> <span class=\"c1\">// 정사각형일때 25를 리턴합니다. 하지만 20이어야 하는게 맞습니다.</span>    <span class=\"nx\">rectangle</span><span class=\"p\">.</span><span class=\"nx\">render</span><span class=\"p\">(</span><span class=\"nx\">area</span><span class=\"p\">);</span>  <span class=\"p\">});</span><span class=\"p\">}</span><span class=\"kd\">const</span> <span class=\"nx\">rectangles</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"k\">new</span> <span class=\"nx\">Rectangle</span><span class=\"p\">(),</span> <span class=\"k\">new</span> <span class=\"nx\">Rectangle</span><span class=\"p\">(),</span> <span class=\"k\">new</span> <span class=\"nx\">Square</span><span class=\"p\">()];</span><span class=\"nx\">renderLargeRectangles</span><span class=\"p\">(</span><span class=\"nx\">rectangles</span><span class=\"p\">);</span></code></pre></div></div><p>좋은 예:</p><div class=\"language-jsx highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nx\">Shape</span> <span class=\"p\">{</span>  <span class=\"nx\">setColor</span><span class=\"p\">(</span><span class=\"nx\">color</span><span class=\"p\">)</span> <span class=\"p\">{</span>    <span class=\"c1\">// ...</span>  <span class=\"p\">}</span>  <span class=\"nx\">render</span><span class=\"p\">(</span><span class=\"nx\">area</span><span class=\"p\">)</span> <span class=\"p\">{</span>    <span class=\"c1\">// ...</span>  <span class=\"p\">}</span><span class=\"p\">}</span><span class=\"kd\">class</span> <span class=\"nx\">Rectangle</span> <span class=\"kd\">extends</span> <span class=\"nx\">Shape</span> <span class=\"p\">{</span>  <span class=\"kd\">constructor</span><span class=\"p\">(</span><span class=\"nx\">width</span><span class=\"p\">,</span> <span class=\"nx\">height</span><span class=\"p\">)</span> <span class=\"p\">{</span>    <span class=\"k\">super</span><span class=\"p\">();</span>    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">width</span> <span class=\"o\">=</span> <span class=\"nx\">width</span><span class=\"p\">;</span>    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">height</span> <span class=\"o\">=</span> <span class=\"nx\">height</span><span class=\"p\">;</span>  <span class=\"p\">}</span>  <span class=\"nx\">getArea</span><span class=\"p\">()</span> <span class=\"p\">{</span>    <span class=\"k\">return</span> <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">width</span> <span class=\"o\">*</span> <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">height</span><span class=\"p\">;</span>  <span class=\"p\">}</span><span class=\"p\">}</span><span class=\"kd\">class</span> <span class=\"nx\">Square</span> <span class=\"kd\">extends</span> <span class=\"nx\">Shape</span> <span class=\"p\">{</span>  <span class=\"kd\">constructor</span><span class=\"p\">(</span><span class=\"nx\">length</span><span class=\"p\">)</span> <span class=\"p\">{</span>    <span class=\"k\">super</span><span class=\"p\">();</span>    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">length</span> <span class=\"o\">=</span> <span class=\"nx\">length</span><span class=\"p\">;</span>  <span class=\"p\">}</span>  <span class=\"nx\">getArea</span><span class=\"p\">()</span> <span class=\"p\">{</span>    <span class=\"k\">return</span> <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">length</span> <span class=\"o\">*</span> <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">length</span><span class=\"p\">;</span>  <span class=\"p\">}</span><span class=\"p\">}</span><span class=\"kd\">function</span> <span class=\"nx\">renderLargeShapes</span><span class=\"p\">(</span><span class=\"nx\">shapes</span><span class=\"p\">)</span> <span class=\"p\">{</span>  <span class=\"nx\">shapes</span><span class=\"p\">.</span><span class=\"nx\">forEach</span><span class=\"p\">((</span><span class=\"nx\">shape</span><span class=\"p\">)</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>    <span class=\"kd\">const</span> <span class=\"nx\">area</span> <span class=\"o\">=</span> <span class=\"nx\">shape</span><span class=\"p\">.</span><span class=\"nx\">getArea</span><span class=\"p\">();</span>    <span class=\"nx\">shape</span><span class=\"p\">.</span><span class=\"nx\">render</span><span class=\"p\">(</span><span class=\"nx\">area</span><span class=\"p\">);</span>  <span class=\"p\">});</span><span class=\"p\">}</span><span class=\"kd\">const</span> <span class=\"nx\">shapes</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"k\">new</span> <span class=\"nx\">Rectangle</span><span class=\"p\">(</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">),</span> <span class=\"k\">new</span> <span class=\"nx\">Rectangle</span><span class=\"p\">(</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">),</span> <span class=\"k\">new</span> <span class=\"nx\">Square</span><span class=\"p\">(</span><span class=\"mi\">5</span><span class=\"p\">)];</span><span class=\"nx\">renderLargeShapes</span><span class=\"p\">(</span><span class=\"nx\">shapes</span><span class=\"p\">);</span></code></pre></div></div><h3 id=\"인터페이스-분리-원칙interface-segregation-principle-isp\"><strong>인터페이스 분리 원칙(Interface Segregation Principle, ISP)</strong></h3><ul>  <li>Javascript에 타입 시스템이 없다 하더라도 중요하고 관계있는 원칙</li>  <li>ISP에 의하면 클라이언트는 사용하지 않는 인터페이스에 의존하도록 강요받으면 안된다. <a href=\"https://ko.wikipedia.org/wiki/%EB%8D%95_%ED%83%80%EC%9D%B4%ED%95%91\">덕 타이핑</a> 때문에 인터페이스는 Javascript에서는 암시적인 계약일 뿐이다.</li>  <li>설정을 선택적으로 할 수 있다면 무거운 인터페이스를 만드는 것을 방지 할 수 있다.</li></ul><p>안좋은 예</p><div class=\"language-jsx highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nx\">DOMTraverser</span> <span class=\"p\">{</span>  <span class=\"kd\">constructor</span><span class=\"p\">(</span><span class=\"nx\">settings</span><span class=\"p\">)</span> <span class=\"p\">{</span>    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">settings</span> <span class=\"o\">=</span> <span class=\"nx\">settings</span><span class=\"p\">;</span>    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">setup</span><span class=\"p\">();</span>  <span class=\"p\">}</span>  <span class=\"nx\">setup</span><span class=\"p\">()</span> <span class=\"p\">{</span>    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">rootNode</span> <span class=\"o\">=</span> <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">settings</span><span class=\"p\">.</span><span class=\"nx\">rootNode</span><span class=\"p\">;</span>    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">animationModule</span><span class=\"p\">.</span><span class=\"nx\">setup</span><span class=\"p\">();</span>  <span class=\"p\">}</span>  <span class=\"nx\">traverse</span><span class=\"p\">()</span> <span class=\"p\">{</span>    <span class=\"c1\">// ...</span>  <span class=\"p\">}</span><span class=\"p\">}</span><span class=\"kd\">const</span> <span class=\"nx\">$</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">DOMTraverser</span><span class=\"p\">({</span>  <span class=\"na\">rootNode</span><span class=\"p\">:</span> <span class=\"nb\">document</span><span class=\"p\">.</span><span class=\"nx\">getElementsByTagName</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">body</span><span class=\"dl\">'</span><span class=\"p\">),</span>  <span class=\"nx\">animationModule</span><span class=\"p\">()</span> <span class=\"p\">{},</span> <span class=\"c1\">// 우리는 대부분의 경우 DOM을 탐색할 때 애니메이션이 필요하지 않습니다.</span>  <span class=\"c1\">// ...</span><span class=\"p\">});</span></code></pre></div></div><p>좋은 예</p><div class=\"language-jsx highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nx\">DOMTraverser</span> <span class=\"p\">{</span>  <span class=\"kd\">constructor</span><span class=\"p\">(</span><span class=\"nx\">settings</span><span class=\"p\">)</span> <span class=\"p\">{</span>    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">settings</span> <span class=\"o\">=</span> <span class=\"nx\">settings</span><span class=\"p\">;</span>    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">options</span> <span class=\"o\">=</span> <span class=\"nx\">settings</span><span class=\"p\">.</span><span class=\"nx\">options</span><span class=\"p\">;</span>    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">setup</span><span class=\"p\">();</span>  <span class=\"p\">}</span>  <span class=\"nx\">setup</span><span class=\"p\">()</span> <span class=\"p\">{</span>    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">rootNode</span> <span class=\"o\">=</span> <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">settings</span><span class=\"p\">.</span><span class=\"nx\">rootNode</span><span class=\"p\">;</span>    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">setupOptions</span><span class=\"p\">();</span>  <span class=\"p\">}</span>  <span class=\"nx\">setupOptions</span><span class=\"p\">()</span> <span class=\"p\">{</span>    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">options</span><span class=\"p\">.</span><span class=\"nx\">animationModule</span><span class=\"p\">)</span> <span class=\"p\">{</span>      <span class=\"c1\">// ...</span>    <span class=\"p\">}</span>  <span class=\"p\">}</span>  <span class=\"nx\">traverse</span><span class=\"p\">()</span> <span class=\"p\">{</span>    <span class=\"c1\">// ...</span>  <span class=\"p\">}</span><span class=\"p\">}</span><span class=\"kd\">const</span> <span class=\"nx\">$</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">DOMTraverser</span><span class=\"p\">({</span>  <span class=\"na\">rootNode</span><span class=\"p\">:</span> <span class=\"nb\">document</span><span class=\"p\">.</span><span class=\"nx\">getElementsByTagName</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">body</span><span class=\"dl\">'</span><span class=\"p\">),</span>  <span class=\"na\">options</span><span class=\"p\">:</span> <span class=\"p\">{</span>    <span class=\"nx\">animationModule</span><span class=\"p\">()</span> <span class=\"p\">{},</span>  <span class=\"p\">},</span><span class=\"p\">});</span></code></pre></div></div><h3 id=\"의존성-역전-원칙-dependency-inversion-principle-dip\"><strong>의존성 역전 원칙 (Dependency Inversion Principle, DIP)</strong></h3><ol>  <li>상위 모듈은 하위 모듈에 종속 되어서는 안된다. 둘 다 추상화에 의존해야 한다.</li>  <li>추상화는 세부사항에 의존하지 않는다. 세부사항은 추상화에 의해 달라져야 한다.</li></ol><p>DI의 장점은 모듈 간의 의존성을 감소시키는 데에 있다. 모듈간의 의존성이 높을수록 코드를 리팩토링 하는데 어려워진다.</p><p>Javascript에는 인터페이스가 없으므로 추상화에 의존하는 것은 암시적인 약속이다. 즉 다른 객체나 클래스에 노출되는 메소드와 속성이 바로 암시적인 약속(추상화)가 된다는 것이다.</p><p>아래 예제에서 암시적인 약속은 InventoryTracker에 대한 모든 요청 모듈이 requestItems 메소드를 가질 것이라는 점이다.</p><p>안좋은 예:</p><div class=\"language-jsx highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nx\">InventoryRequester</span> <span class=\"p\">{</span>  <span class=\"kd\">constructor</span><span class=\"p\">()</span> <span class=\"p\">{</span>    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">REQ_METHODS</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"dl\">'</span><span class=\"s1\">HTTP</span><span class=\"dl\">'</span><span class=\"p\">];</span>  <span class=\"p\">}</span>  <span class=\"nx\">requestItem</span><span class=\"p\">(</span><span class=\"nx\">item</span><span class=\"p\">)</span> <span class=\"p\">{</span>    <span class=\"c1\">// ...</span>  <span class=\"p\">}</span><span class=\"p\">}</span><span class=\"kd\">class</span> <span class=\"nx\">InventoryTracker</span> <span class=\"p\">{</span>  <span class=\"kd\">constructor</span><span class=\"p\">(</span><span class=\"nx\">items</span><span class=\"p\">)</span> <span class=\"p\">{</span>    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">items</span> <span class=\"o\">=</span> <span class=\"nx\">items</span><span class=\"p\">;</span>    <span class=\"c1\">// 안좋은 이유: 특정 요청방법 구현에 대한 의존성을 만들었습니다.</span>    <span class=\"c1\">// requestItems는 한가지 요청방법을 필요로 합니다.</span>    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">requester</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">InventoryRequester</span><span class=\"p\">();</span>  <span class=\"p\">}</span>  <span class=\"nx\">requestItems</span><span class=\"p\">()</span> <span class=\"p\">{</span>    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">items</span><span class=\"p\">.</span><span class=\"nx\">forEach</span><span class=\"p\">((</span><span class=\"nx\">item</span><span class=\"p\">)</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>      <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">requester</span><span class=\"p\">.</span><span class=\"nx\">requestItem</span><span class=\"p\">(</span><span class=\"nx\">item</span><span class=\"p\">);</span>    <span class=\"p\">});</span>  <span class=\"p\">}</span><span class=\"p\">}</span><span class=\"kd\">const</span> <span class=\"nx\">inventoryTracker</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">InventoryTracker</span><span class=\"p\">([</span><span class=\"dl\">'</span><span class=\"s1\">apples</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"dl\">'</span><span class=\"s1\">bananas</span><span class=\"dl\">'</span><span class=\"p\">]);</span><span class=\"nx\">inventoryTracker</span><span class=\"p\">.</span><span class=\"nx\">requestItems</span><span class=\"p\">();</span></code></pre></div></div><p>좋은 예:</p><div class=\"language-jsx highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nx\">InventoryTracker</span> <span class=\"p\">{</span>  <span class=\"kd\">constructor</span><span class=\"p\">(</span><span class=\"nx\">items</span><span class=\"p\">,</span> <span class=\"nx\">requester</span><span class=\"p\">)</span> <span class=\"p\">{</span>    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">items</span> <span class=\"o\">=</span> <span class=\"nx\">items</span><span class=\"p\">;</span>    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">requester</span> <span class=\"o\">=</span> <span class=\"nx\">requester</span><span class=\"p\">;</span>  <span class=\"p\">}</span>  <span class=\"nx\">requestItems</span><span class=\"p\">()</span> <span class=\"p\">{</span>    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">items</span><span class=\"p\">.</span><span class=\"nx\">forEach</span><span class=\"p\">((</span><span class=\"nx\">item</span><span class=\"p\">)</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>      <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">requester</span><span class=\"p\">.</span><span class=\"nx\">requestItem</span><span class=\"p\">(</span><span class=\"nx\">item</span><span class=\"p\">);</span>    <span class=\"p\">});</span>  <span class=\"p\">}</span><span class=\"p\">}</span><span class=\"kd\">class</span> <span class=\"nx\">InventoryRequesterV1</span> <span class=\"p\">{</span>  <span class=\"kd\">constructor</span><span class=\"p\">()</span> <span class=\"p\">{</span>    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">REQ_METHODS</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"dl\">'</span><span class=\"s1\">HTTP</span><span class=\"dl\">'</span><span class=\"p\">];</span>  <span class=\"p\">}</span>  <span class=\"nx\">requestItem</span><span class=\"p\">(</span><span class=\"nx\">item</span><span class=\"p\">)</span> <span class=\"p\">{</span>    <span class=\"c1\">// ...</span>  <span class=\"p\">}</span><span class=\"p\">}</span><span class=\"kd\">class</span> <span class=\"nx\">InventoryRequesterV2</span> <span class=\"p\">{</span>  <span class=\"kd\">constructor</span><span class=\"p\">()</span> <span class=\"p\">{</span>    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">REQ_METHODS</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"dl\">'</span><span class=\"s1\">WS</span><span class=\"dl\">'</span><span class=\"p\">];</span>  <span class=\"p\">}</span>  <span class=\"nx\">requestItem</span><span class=\"p\">(</span><span class=\"nx\">item</span><span class=\"p\">)</span> <span class=\"p\">{</span>    <span class=\"c1\">// ...</span>  <span class=\"p\">}</span><span class=\"p\">}</span><span class=\"c1\">// 의존성을 외부에서 만들어 주입해줌으로써,</span><span class=\"c1\">// 요청 모듈을 새롭게 만든 웹소켓 사용 모듈로 쉽게 바꿔 끼울 수 있게 되었습니다.</span><span class=\"kd\">const</span> <span class=\"nx\">inventoryTracker</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">InventoryTracker</span><span class=\"p\">(</span>  <span class=\"p\">[</span><span class=\"dl\">'</span><span class=\"s1\">apples</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"dl\">'</span><span class=\"s1\">bananas</span><span class=\"dl\">'</span><span class=\"p\">],</span>  <span class=\"k\">new</span> <span class=\"nx\">InventoryRequesterV2</span><span class=\"p\">(),</span><span class=\"p\">);</span><span class=\"nx\">inventoryTracker</span><span class=\"p\">.</span><span class=\"nx\">requestItems</span><span class=\"p\">();</span></code></pre></div></div>",
            "url": "https://thehue.github.io/2022/05/10/til-%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C-10%EC%9E%A5-%ED%81%B4%EB%9E%98%EC%8A%A4",
            
            
            
            "tags": ["노마드코더","북클럽","노개북","노마드북클럽","코딩","개발자","TIL"],
            
            "date_published": "2022-05-10T00:00:00+09:00",
            "date_modified": "2022-05-10T00:00:00+09:00",
            
                "author":  {
                "name": "thehue",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://thehue.github.io/2022/05/07/til-%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C-9%EC%9E%A5-%EB%8B%A8%EC%9C%84-%ED%85%8C%EC%8A%A4%ED%8A%B8",
            "title": "TIL 클린코드 - 9장. 단위 테스트",
            "summary": "책 클린코드 9장 단위 테스트 내용으로 테스트 코드의 중요성과 방법에 대한 내용이다.",
            "content_text": "TIL (Today I Learned)ㅍ2022.05.07오늘 읽은 범위9장. 단위 테스트책에서 기억하고 싶은 내용을 써보세요.  TDD 법칙 세가지          첫째 법칙: 실패하는 단위 테스트를 작성할 때 까지 실제 코드를 작성하지 않는다.      둘째 법칙: 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다.      셋째 법칙: 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.      실제 코드와 맞먹을 정도로 방대한 테스트 코드는 심각한 관리 문제를 유발하기도 한다.        깨끗한 테스트 코드 유지하기          지저분한 테스트 코드를 내놓으나 테스트를 안 하나 오십보 백보라는, 아니 오히려 더 못하다는 사실을 깨닫지 못했다.      새 버전을 출시할 때마다 팀이 테스트 케이스를 유지하고 보수하는 비용도 늘어난다. 점차 테스트 코드는 개발자 사이에서 가장 큰 불만으로 자리잡는다.      하지만 테스트 슈트가 없으면 시스템 이쪽을 수정해도 저쪽이 안전하다는 사실을 검증하지 못한다.      코드에 유연성, 유지보수성, 재사용성을 제공하는 버팀목이 바로 단위테스트다.      테스트 커버리지가 높을수록 공포는 줄어든다.        깨끗한 테스트 코드          깨끗한 테스트 코드를 만들려면 세 가지가 필요하다. 가독성, 가독성, 가독성.      첫 부분은 테스트 자료를 만든다. 두 번째 부분은 테스트 자료를 조작하며, 세 번째 부분은 조작한 결과가 올바른지 확인한다.      이중 표준 - 테스트 API 코드에 적용하는 표준은 실제 코드에 적용하는 표준과 확실히 다르다. 단순하고, 간결하고, 표현력이 풍부해야 하지만, 실제 코드만큼 효율적일 필요는 없다.            테스트 당 assert 하나          assert문이 단 하나인 함수는 결론이 하나라서 코드를 이해하기 쉽고 빠르다.      하지만 특정 케이스에는 assert 문을 하나로 병합하는 방식이 불합리하기 때문에 테스트를 두 개로 쪼개 각자가 assert를 수행하면 된다.        // 출력이 XML이다.public void testGetPageHierarchyAsXml() throws Exception {\tgivenPages(\"PageOne\", \"PageOne.ChildOne\", \"PageTwo\");\twhenRequestIsIssued(\"root\", \"type:pages\");\tthenResponseShouldBeXML();}// 특정 문자열을 포함한다.public void testGetPageHierarchyHasRightTags() throws Exception {\tgivenPages(\"PageOne\", \"PageOne.ChildOne\", \"PageTwo\");\twhenRequestIsIssued(\"root\", \"type:pages\");\tthenResponseShouldContain(\t\t\"&lt;name&gt;PageOne&lt;/name&gt;\", \"&lt;name&gt;PageTwo&lt;/name&gt;\", \"&lt;name&gt;ChildOne&lt;/name&gt;\");  );}              함수 이름은 given-when-then 관례를 잘 사용하자.      중복 제거하는 법                  given/when 부분을 부모 클래스에 두고 then 부분을 자식 클래스에 두면 된다. 아니면 독자적인 테스트 클래스를 만들어 @Before 함수에 given/when 부분을 넣고 @Test 함수에 then 부분을 넣어도 된다.          하지만 모두가 배보다 배꼽이 더 크다. 이것 저것 감안해 보면 assert 문을 여럿 사용하는 편이 좋다고 생각한다.                    가장 좋은 규칙은 개념 당 assert 문 수를 최소로 줄여라와 테스트 함수 하나는 개념 하나만 테스트하라        F.I.R.S.T          Fast: 테스트는 빨리 돌아야 한다.      Independent: 각 테스트는 서로 의존하면 안된다. 각 테스트는 독립적으로 그리고 어떤 순서로 실행해도 괜찮아야 한다.      Repeatable: 테스트는 어떤 환경에서도 반복 가능해야 한다. 테스트가 돌아가지 않는 환경이 하나라도 있다면 테스트가 실패한 이유를 둘러댈 변명이 생긴다.      Self-Validating: 테스트는 bool값으로 결과를 내야 한다. 테스트가 스스로 성공과 실패를 가늠하지 않는다면 판단은 주관적으로 되며 지루한 수작업 평가가 필요하게 된다.      Timely: 테스트는 적시에 작성해야 한다. 단위 테스트는 테스트 하려는 실제 코드를 구현하기 직전에 구현한다. 어떤 실제 코드는 테스트하기 너무 어렵다고 판명날지 모른다. 테스트가 불가능하도록 실제 코드를 설계할지도 모른다.      오늘 읽은 소감은? 떠오르는 생각을 가볍게 적어보세요  최근에 진행한 프로젝트에서 특정 페이지에 기능을 추가한적이 있었다. 아주 간단한 기능이라 버그가 없을 거라 생각하고 배포했는데, 기존에 잘 됐던 기능이 새로운 기능 추가로 인한 코드 수정 때문에 잘 작동하지 않아서 문제가 되었던 경험이 있다. 해당 페이지는 테스트 코드가 없었는데 테스트 케이스를 작성했다면 해당 버그를 사전에 잡을 수 있었을텐데..라며 아쉬워했다. 그래서 책을 읽으면서 테스트 슈트가 없으면 시스템 이쪽을 수정해도 저쪽이 안전하다는 사실을 검증하지 못한다. 라는 문구에 격공을 했다.  테스트 코드 작성법이 익숙하지 않기도 하고 기능 구현에 급급해서 테스트 코드를 많이 작성하지 못한다. 그래서 전에는 실제 코드를 다 짜놓고 테스트 코드를 짜면서 굳이 실제 코드전에 짜야할 이유가 있을까? 하고 생각한 적이 있는데, 깨끗한 테스트 다섯가지 규칙을 이번에 읽고 이유를 알게 되었다. 적시에 작성하지 않으면 테스트가 불가능하도록 실제코드를 설계할 가능성이 커지고 그러면 테스트 코드를 작성하지 않을 가능성도 높아지기 때문이다. 테스트 코드 작성법을 더 능숙하게 익혀서 실제 기능 구현 전에 능숙하게 짜보고 싶다.더 공부한 내용  다양한 javascript 테스트 프레임워크 모음 링크",
            "content_html": "<p><strong>TIL (Today I Learned)</strong>ㅍ</p><p>2022.05.07</p><p><strong>오늘 읽은 범위</strong></p><p>9장. 단위 테스트</p><p><strong>책에서 기억하고 싶은 내용을 써보세요.</strong></p><ul>  <li>TDD 법칙 세가지    <ul>      <li>첫째 법칙: 실패하는 단위 테스트를 작성할 때 까지 실제 코드를 작성하지 않는다.</li>      <li>둘째 법칙: 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다.</li>      <li>셋째 법칙: 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.</li>      <li>실제 코드와 맞먹을 정도로 방대한 테스트 코드는 심각한 관리 문제를 유발하기도 한다.</li>    </ul>  </li>  <li>깨끗한 테스트 코드 유지하기    <ul>      <li>지저분한 테스트 코드를 내놓으나 테스트를 안 하나 오십보 백보라는, 아니 오히려 더 못하다는 사실을 깨닫지 못했다.</li>      <li>새 버전을 출시할 때마다 팀이 테스트 케이스를 유지하고 보수하는 비용도 늘어난다. 점차 테스트 코드는 개발자 사이에서 가장 큰 불만으로 자리잡는다.</li>      <li>하지만 테스트 슈트가 없으면 시스템 이쪽을 수정해도 저쪽이 안전하다는 사실을 검증하지 못한다.</li>      <li>코드에 유연성, 유지보수성, 재사용성을 제공하는 버팀목이 바로 단위테스트다.</li>      <li>테스트 커버리지가 높을수록 공포는 줄어든다.</li>    </ul>  </li>  <li>깨끗한 테스트 코드    <ul>      <li>깨끗한 테스트 코드를 만들려면 세 가지가 필요하다. 가독성, 가독성, 가독성.</li>      <li>첫 부분은 테스트 자료를 만든다. 두 번째 부분은 테스트 자료를 조작하며, 세 번째 부분은 조작한 결과가 올바른지 확인한다.</li>      <li>이중 표준 - 테스트 API 코드에 적용하는 표준은 실제 코드에 적용하는 표준과 확실히 다르다. 단순하고, 간결하고, 표현력이 풍부해야 하지만, 실제 코드만큼 효율적일 필요는 없다.</li>    </ul>  </li>  <li>    <p>테스트 당 assert 하나</p>    <ul>      <li>assert문이 단 하나인 함수는 결론이 하나라서 코드를 이해하기 쉽고 빠르다.</li>      <li>하지만 특정 케이스에는 assert 문을 하나로 병합하는 방식이 불합리하기 때문에 테스트를 두 개로 쪼개 각자가 assert를 수행하면 된다.</li>    </ul>    <div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 출력이 XML이다.</span><span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">testGetPageHierarchyAsXml</span><span class=\"o\">()</span> <span class=\"kd\">throws</span> <span class=\"nc\">Exception</span> <span class=\"o\">{</span>\t<span class=\"n\">givenPages</span><span class=\"o\">(</span><span class=\"s\">\"PageOne\"</span><span class=\"o\">,</span> <span class=\"s\">\"PageOne.ChildOne\"</span><span class=\"o\">,</span> <span class=\"s\">\"PageTwo\"</span><span class=\"o\">);</span>\t<span class=\"n\">whenRequestIsIssued</span><span class=\"o\">(</span><span class=\"s\">\"root\"</span><span class=\"o\">,</span> <span class=\"s\">\"type:pages\"</span><span class=\"o\">);</span>\t<span class=\"n\">thenResponseShouldBeXML</span><span class=\"o\">();</span><span class=\"o\">}</span><span class=\"c1\">// 특정 문자열을 포함한다.</span><span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">testGetPageHierarchyHasRightTags</span><span class=\"o\">()</span> <span class=\"kd\">throws</span> <span class=\"nc\">Exception</span> <span class=\"o\">{</span>\t<span class=\"n\">givenPages</span><span class=\"o\">(</span><span class=\"s\">\"PageOne\"</span><span class=\"o\">,</span> <span class=\"s\">\"PageOne.ChildOne\"</span><span class=\"o\">,</span> <span class=\"s\">\"PageTwo\"</span><span class=\"o\">);</span>\t<span class=\"n\">whenRequestIsIssued</span><span class=\"o\">(</span><span class=\"s\">\"root\"</span><span class=\"o\">,</span> <span class=\"s\">\"type:pages\"</span><span class=\"o\">);</span>\t<span class=\"n\">thenResponseShouldContain</span><span class=\"o\">(</span>\t\t<span class=\"s\">\"&lt;name&gt;PageOne&lt;/name&gt;\"</span><span class=\"o\">,</span> <span class=\"s\">\"&lt;name&gt;PageTwo&lt;/name&gt;\"</span><span class=\"o\">,</span> <span class=\"s\">\"&lt;name&gt;ChildOne&lt;/name&gt;\"</span><span class=\"o\">);</span>  <span class=\"o\">);</span><span class=\"o\">}</span></code></pre></div>    </div>    <ul>      <li>함수 이름은 given-when-then 관례를 잘 사용하자.</li>      <li>중복 제거하는 법        <ul>          <li>given/when 부분을 부모 클래스에 두고 then 부분을 자식 클래스에 두면 된다. 아니면 독자적인 테스트 클래스를 만들어 @Before 함수에 given/when 부분을 넣고 @Test 함수에 then 부분을 넣어도 된다.</li>          <li>하지만 모두가 배보다 배꼽이 더 크다. 이것 저것 감안해 보면 assert 문을 여럿 사용하는 편이 좋다고 생각한다.</li>        </ul>      </li>      <li>가장 좋은 규칙은 <code class=\"language-plaintext highlighter-rouge\">개념 당 assert 문 수를 최소로 줄여라</code>와 <code class=\"language-plaintext highlighter-rouge\">테스트 함수 하나는 개념 하나만 테스트하라</code></li>    </ul>  </li>  <li>F.I.R.S.T    <ol>      <li>Fast: 테스트는 빨리 돌아야 한다.</li>      <li>Independent: 각 테스트는 서로 의존하면 안된다. 각 테스트는 독립적으로 그리고 어떤 순서로 실행해도 괜찮아야 한다.</li>      <li>Repeatable: 테스트는 어떤 환경에서도 반복 가능해야 한다. 테스트가 돌아가지 않는 환경이 하나라도 있다면 테스트가 실패한 이유를 둘러댈 변명이 생긴다.</li>      <li>Self-Validating: 테스트는 bool값으로 결과를 내야 한다. 테스트가 스스로 성공과 실패를 가늠하지 않는다면 판단은 주관적으로 되며 지루한 수작업 평가가 필요하게 된다.</li>      <li>Timely: 테스트는 적시에 작성해야 한다. 단위 테스트는 테스트 하려는 실제 코드를 구현하기 직전에 구현한다. 어떤 실제 코드는 테스트하기 너무 어렵다고 판명날지 모른다. 테스트가 불가능하도록 실제 코드를 설계할지도 모른다.</li>    </ol>  </li></ul><p><strong>오늘 읽은 소감은? 떠오르는 생각을 가볍게 적어보세요</strong></p><ul>  <li>최근에 진행한 프로젝트에서 특정 페이지에 기능을 추가한적이 있었다. 아주 간단한 기능이라 버그가 없을 거라 생각하고 배포했는데, 기존에 잘 됐던 기능이 새로운 기능 추가로 인한 코드 수정 때문에 잘 작동하지 않아서 문제가 되었던 경험이 있다. 해당 페이지는 테스트 코드가 없었는데 테스트 케이스를 작성했다면 해당 버그를 사전에 잡을 수 있었을텐데..라며 아쉬워했다. 그래서 책을 읽으면서 <em><code class=\"language-plaintext highlighter-rouge\">테스트 슈트가 없으면 시스템 이쪽을 수정해도 저쪽이 안전하다는 사실을 검증하지 못한다.</code></em> 라는 문구에 격공을 했다.</li>  <li>테스트 코드 작성법이 익숙하지 않기도 하고 기능 구현에 급급해서 테스트 코드를 많이 작성하지 못한다. 그래서 전에는 실제 코드를 다 짜놓고 테스트 코드를 짜면서 굳이 실제 코드전에 짜야할 이유가 있을까? 하고 생각한 적이 있는데, 깨끗한 테스트 다섯가지 규칙을 이번에 읽고 이유를 알게 되었다. 적시에 작성하지 않으면 테스트가 불가능하도록 실제코드를 설계할 가능성이 커지고 그러면 테스트 코드를 작성하지 않을 가능성도 높아지기 때문이다. 테스트 코드 작성법을 더 능숙하게 익혀서 실제 기능 구현 전에 능숙하게 짜보고 싶다.</li></ul><p><strong>더 공부한 내용</strong></p><ul>  <li><a href=\"https://jstherightway.org/#testing-tools\">다양한 javascript 테스트 프레임워크 모음 링크</a></li></ul>",
            "url": "https://thehue.github.io/2022/05/07/til-%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C-9%EC%9E%A5-%EB%8B%A8%EC%9C%84-%ED%85%8C%EC%8A%A4%ED%8A%B8",
            
            
            
            "tags": ["노마드코더","북클럽","노개북","노마드북클럽","코딩","개발자","TIL"],
            
            "date_published": "2022-05-07T00:00:00+09:00",
            "date_modified": "2022-05-07T00:00:00+09:00",
            
                "author":  {
                "name": "thehue",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://thehue.github.io/2022/05/05/til-%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C-7%EC%9E%A5-%EC%98%A4%EB%A5%98%EC%B2%98%EB%A6%AC",
            "title": "TIL 클린코드 - 7장. 오류처리",
            "summary": "책 클린코드 7장 깨끗하고 튼튼한 코드에 한걸음 더 다가가는 단계로 우아하고 고상하게 오류를 처리하는 기법과 고려 사항을 소개",
            "content_text": "TIL (Today I Learned)2022.05.05오늘 읽은 범위7장. 오류처리책에서 기억하고 싶은 내용을 써보세요.  뭔가 잘못될 가능성은 늘 존재한다. 뭔가 잘못되면 바로 잡을 책임은 바로 우리 프로그래머에게 있다.  오류 처리는 중요하다. 하지만 오류 처리 코드로 인해 프로그램 논리를 이해하기 어려워 진다면 깨끗한 코드라 부르기 어렵다.  오류 코드보다 예외를 사용하라          논리가 오류 처리 코드와 뒤섞이지 않으니까 호출자 코드가 더 깔끔해진다.        Try-Catch-Finally 문부터 작성하라          try 블록에서 무슨 일이 생기든지 catch 블록은 프로그램 상태를 일관성 있게 유지해야 한다.      먼저 강제로 예외를 일으키는 테스트 케이스를 작성한 후 테스트를 통과하게 코드를 작성하는 방법을 권장한다.        미확인 예외를 사용하라          안정적인 소프트웨어를 제작하는 요소로 확인된 예외가 반드시 필요하지는 않다는 사실이 분명해졌다.      확인된 예외는 하위 단계에서 코드를 번경하면 상위 단계 메서드 선언부를 전부 고쳐야 하는 단점이 있기 때문이다.        예외에 의미를 제공하라          오류 메세지에 정보를 담아 예외와 함께 던진다. 실패한 연산 이름과 실패 유형도 언급한다.        호출자를 고려해 예외 클래스를 정의하라          애플리케이션에서 오류를 정의할 때 프로그래머에게 가장 중요한 관심사는 오류를 잡아내는 방법이 되어야 한다.      외부 API를 사용할 때는 감싸기 기법이 최선이다. 외부 API를 감싸면 외부 라이브러리와 프로그램 사이에서 의존성이 크게 줄어든다.      실패를 표현하는 예외 유형 하나만 정의해도 프로그램이 훨씬 깨끗해진다.            정상 흐름을 정의하라          독자적인 예외를 던지고 코드 위에 처리기를 정의해 중단된 계산을 처리한다. 대게는 멋진 처리 방식이지만, 때로는 중단이 적합하지 않은 때도 있다.        나쁜 예    // 비용 청구 애플리케이션에서 총계를 계산하는 허술한 코드try{  MealExpenses expenses = expenseReportDAO.getMeals(employee.getID());  m_total += expenses.getTotal();} catch(MealExpensesNoFound e){  m_total += expenses.getMealPerDiem();}// 예외가 논리를 따라가기 어렵게 만든다        좋은 예    // 특수 상황을 처리할 필요가 없게 만드는 것이 더 좋다 (SPECIAL CASE PATTERN)MealExpenses expenses = expenseReportDAO.getMeals(employee.getID());m_total += expenses.getTotal();public class PerDiemMealExpenses implements MealExpenses {  public int getTotal() {    // 기본값으로 일일 기본 식비를 반환한다.  }}                null을 반환하지 마라          메서드에서 null을 반환하고픈 유혹이 든다면 그 대신 예외를 던지거나 특수 사례 객체를 반환한다(ex. 빈 리스트)        null을 전달하지 마라          정상적인 인수로 null을 기대하는 API가 아니라면 메서드로 null을 전달하는 코드는 최대한 피한다.        깨끗한 코드는 읽기도 좋아야 하지만 안정성도 높아야 한다. 오류 처리를 프로그램 논리와 분리해 독자적인 시안으로 고려하면 튼튼하고 깨끗한 코드를 작성할 수 있다.오늘 읽은 소감은? 떠오르는 생각을 가볍게 적어보세요  실무를 하다보면 오류처리는 정말 중요하다고 생각한다. 정말 철저하게 검증해봤다고 생각했는데 이게 오류가 난다고? 하는 일이 생각보다 많이 일어나기 때문이다.  최근에 한 프로젝트에서 백엔드 API가 오류처리가 제대로 되지 않아 모든 에러코드가 500에러로 넘어와서 고생한 적이 있다. 이런 상황이 되면 프론트가 데이터를 잘못 전달해서 나는 에런지 백쪽 문제인지 알 수가 없다. 오류 처리는 프론트와 백엔드가 뚫리지 않는 방패처럼 철저하게 처리 해야한다.      현재 회사에서 프론트 측에서 서버 데이터를 관리할 때 react-query를 사용하는데 react-query는 비동기 과정 에러 핸들링을 정말 편하게 할 수 있다. 다음과 같이 사용할 수 있다.    import { useQueryErrorResetBoundary } from 'react-query';import { ErrorBoundary } from 'react-error-boundary';const App: React.FC = () =&gt; {  const { reset } = useQueryErrorResetBoundary();  return (    &lt;ErrorBoundary      onReset={reset}      fallbackRender={({ resetErrorBoundary }) =&gt; (        &lt;div&gt;          There was an error!          &lt;Button onClick={() =&gt; resetErrorBoundary()}&gt;Try again&lt;/Button&gt;        &lt;/div&gt;      )}    &gt;      &lt;Page /&gt;    &lt;/ErrorBoundary&gt;  );};        깨끗한 코드는 읽기도 좋아야 하지만 안정성도 높아야한다는 말에 핵공감이다. 코드가 아무리 깨끗해도 버그가 많이 발생하는 코드라면 깨끗한 코드도 의미가 없어진다.궁금한 내용이 있거나, 잘 이해되지 않는 내용이 있다면 적어보세요.  javascript 오류처리에 대한 좋은 글들이 많아 아래 링크로 걸어둔다.          [JS] try…catch 그리고 에러 핸들링        Clean Code concepts adapted for JavaScript - 한글 번역판의 에러처리 부분을 가져온 내용이다.          try/catch로 어떤 코드를 감쌌다면 그에 대한 계획이 있거나 어떠한 장치를 해야한다.      안 좋은 예)try {  functionThatMightThrow();} catch (error) {  console.log(error);}좋은 예)try {  functionThatMightThrow();} catch (error) {  // 첫번째 방법은 console.error를 이용하는 것입니다. 이건 console.log보다 조금 더 알아채기 쉽습니다.  console.error(error);  // 다른 방법은 유저에게 알리는 방법입니다.  notifyUserOfError(error);  // 또 다른 방법은 서비스 자체에 에러를 기록하는 방법입니다.  reportErrorToService(error);  // 혹은 그 어떤 방법이 될 수 있습니다.}",
            "content_html": "<p><strong>TIL (Today I Learned)</strong></p><p>2022.05.05</p><p><strong>오늘 읽은 범위</strong></p><p>7장. 오류처리</p><p><strong>책에서 기억하고 싶은 내용을 써보세요.</strong></p><ul>  <li>뭔가 잘못될 가능성은 늘 존재한다. 뭔가 잘못되면 바로 잡을 책임은 바로 우리 프로그래머에게 있다.</li>  <li>오류 처리는 중요하다. 하지만 오류 처리 코드로 인해 프로그램 논리를 이해하기 어려워 진다면 깨끗한 코드라 부르기 어렵다.</li>  <li>오류 코드보다 예외를 사용하라    <ul>      <li>논리가 오류 처리 코드와 뒤섞이지 않으니까 호출자 코드가 더 깔끔해진다.</li>    </ul>  </li>  <li>Try-Catch-Finally 문부터 작성하라    <ul>      <li>try 블록에서 무슨 일이 생기든지 catch 블록은 프로그램 상태를 일관성 있게 유지해야 한다.</li>      <li>먼저 강제로 예외를 일으키는 테스트 케이스를 작성한 후 테스트를 통과하게 코드를 작성하는 방법을 권장한다.</li>    </ul>  </li>  <li>미확인 예외를 사용하라    <ul>      <li>안정적인 소프트웨어를 제작하는 요소로 확인된 예외가 반드시 필요하지는 않다는 사실이 분명해졌다.</li>      <li>확인된 예외는 하위 단계에서 코드를 번경하면 상위 단계 메서드 선언부를 전부 고쳐야 하는 단점이 있기 때문이다.</li>    </ul>  </li>  <li>예외에 의미를 제공하라    <ul>      <li>오류 메세지에 정보를 담아 예외와 함께 던진다. 실패한 연산 이름과 실패 유형도 언급한다.</li>    </ul>  </li>  <li>호출자를 고려해 예외 클래스를 정의하라    <ul>      <li>애플리케이션에서 오류를 정의할 때 프로그래머에게 가장 중요한 관심사는 오류를 잡아내는 방법이 되어야 한다.</li>      <li>외부 API를 사용할 때는 감싸기 기법이 최선이다. 외부 API를 감싸면 외부 라이브러리와 프로그램 사이에서 의존성이 크게 줄어든다.</li>      <li>실패를 표현하는 예외 유형 하나만 정의해도 프로그램이 훨씬 깨끗해진다.</li>    </ul>  </li>  <li>    <p>정상 흐름을 정의하라</p>    <ul>      <li>독자적인 예외를 던지고 코드 위에 처리기를 정의해 중단된 계산을 처리한다. 대게는 멋진 처리 방식이지만, 때로는 중단이 적합하지 않은 때도 있다.</li>    </ul>    <p>나쁜 예</p>    <div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 비용 청구 애플리케이션에서 총계를 계산하는 허술한 코드</span><span class=\"k\">try</span><span class=\"o\">{</span>  <span class=\"nc\">MealExpenses</span> <span class=\"n\">expenses</span> <span class=\"o\">=</span> <span class=\"n\">expenseReportDAO</span><span class=\"o\">.</span><span class=\"na\">getMeals</span><span class=\"o\">(</span><span class=\"n\">employee</span><span class=\"o\">.</span><span class=\"na\">getID</span><span class=\"o\">());</span>  <span class=\"n\">m_total</span> <span class=\"o\">+=</span> <span class=\"n\">expenses</span><span class=\"o\">.</span><span class=\"na\">getTotal</span><span class=\"o\">();</span><span class=\"o\">}</span> <span class=\"k\">catch</span><span class=\"o\">(</span><span class=\"nc\">MealExpensesNoFound</span> <span class=\"n\">e</span><span class=\"o\">){</span>  <span class=\"n\">m_total</span> <span class=\"o\">+=</span> <span class=\"n\">expenses</span><span class=\"o\">.</span><span class=\"na\">getMealPerDiem</span><span class=\"o\">();</span><span class=\"o\">}</span><span class=\"c1\">// 예외가 논리를 따라가기 어렵게 만든다</span></code></pre></div>    </div>    <p>좋은 예</p>    <div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 특수 상황을 처리할 필요가 없게 만드는 것이 더 좋다 (SPECIAL CASE PATTERN)</span><span class=\"nc\">MealExpenses</span> <span class=\"n\">expenses</span> <span class=\"o\">=</span> <span class=\"n\">expenseReportDAO</span><span class=\"o\">.</span><span class=\"na\">getMeals</span><span class=\"o\">(</span><span class=\"n\">employee</span><span class=\"o\">.</span><span class=\"na\">getID</span><span class=\"o\">());</span><span class=\"n\">m_total</span> <span class=\"o\">+=</span> <span class=\"n\">expenses</span><span class=\"o\">.</span><span class=\"na\">getTotal</span><span class=\"o\">();</span><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">PerDiemMealExpenses</span> <span class=\"kd\">implements</span> <span class=\"nc\">MealExpenses</span> <span class=\"o\">{</span>  <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">getTotal</span><span class=\"o\">()</span> <span class=\"o\">{</span>    <span class=\"c1\">// 기본값으로 일일 기본 식비를 반환한다.</span>  <span class=\"o\">}</span><span class=\"o\">}</span></code></pre></div>    </div>    <div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code></code></pre></div>    </div>  </li>  <li>null을 반환하지 마라    <ul>      <li>메서드에서 null을 반환하고픈 유혹이 든다면 그 대신 예외를 던지거나 특수 사례 객체를 반환한다(ex. 빈 리스트)</li>    </ul>  </li>  <li>null을 전달하지 마라    <ul>      <li>정상적인 인수로 null을 기대하는 API가 아니라면 메서드로 null을 전달하는 코드는 최대한 피한다.</li>    </ul>  </li>  <li>깨끗한 코드는 읽기도 좋아야 하지만 안정성도 높아야 한다. 오류 처리를 프로그램 논리와 분리해 독자적인 시안으로 고려하면 튼튼하고 깨끗한 코드를 작성할 수 있다.</li></ul><p><strong>오늘 읽은 소감은? 떠오르는 생각을 가볍게 적어보세요</strong></p><ul>  <li>실무를 하다보면 오류처리는 정말 중요하다고 생각한다. 정말 철저하게 검증해봤다고 생각했는데 이게 오류가 난다고? 하는 일이 생각보다 많이 일어나기 때문이다.</li>  <li>최근에 한 프로젝트에서 백엔드 API가 오류처리가 제대로 되지 않아 모든 에러코드가 500에러로 넘어와서 고생한 적이 있다. 이런 상황이 되면 프론트가 데이터를 잘못 전달해서 나는 에런지 백쪽 문제인지 알 수가 없다. 오류 처리는 프론트와 백엔드가 뚫리지 않는 방패처럼 철저하게 처리 해야한다.</li>  <li>    <p>현재 회사에서 프론트 측에서 서버 데이터를 관리할 때 react-query를 사용하는데 react-query는 비동기 과정 에러 핸들링을 정말 편하게 할 수 있다. 다음과 같이 사용할 수 있다.</p>    <div class=\"language-jsx highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">import</span> <span class=\"p\">{</span> <span class=\"nx\">useQueryErrorResetBoundary</span> <span class=\"p\">}</span> <span class=\"k\">from</span> <span class=\"dl\">'</span><span class=\"s1\">react-query</span><span class=\"dl\">'</span><span class=\"p\">;</span><span class=\"k\">import</span> <span class=\"p\">{</span> <span class=\"nx\">ErrorBoundary</span> <span class=\"p\">}</span> <span class=\"k\">from</span> <span class=\"dl\">'</span><span class=\"s1\">react-error-boundary</span><span class=\"dl\">'</span><span class=\"p\">;</span><span class=\"kd\">const</span> <span class=\"nx\">App</span><span class=\"p\">:</span> <span class=\"nx\">React</span><span class=\"p\">.</span><span class=\"nx\">FC</span> <span class=\"o\">=</span> <span class=\"p\">()</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>  <span class=\"kd\">const</span> <span class=\"p\">{</span> <span class=\"nx\">reset</span> <span class=\"p\">}</span> <span class=\"o\">=</span> <span class=\"nx\">useQueryErrorResetBoundary</span><span class=\"p\">();</span>  <span class=\"k\">return</span> <span class=\"p\">(</span>    <span class=\"p\">&lt;</span><span class=\"nc\">ErrorBoundary</span>      <span class=\"na\">onReset</span><span class=\"p\">=</span><span class=\"si\">{</span><span class=\"nx\">reset</span><span class=\"si\">}</span>      <span class=\"na\">fallbackRender</span><span class=\"p\">=</span><span class=\"si\">{</span><span class=\"p\">({</span> <span class=\"nx\">resetErrorBoundary</span> <span class=\"p\">})</span> <span class=\"o\">=&gt;</span> <span class=\"p\">(</span>        <span class=\"p\">&lt;</span><span class=\"nt\">div</span><span class=\"p\">&gt;</span>          There was an error!          <span class=\"p\">&lt;</span><span class=\"nc\">Button</span> <span class=\"na\">onClick</span><span class=\"p\">=</span><span class=\"si\">{</span><span class=\"p\">()</span> <span class=\"o\">=&gt;</span> <span class=\"nx\">resetErrorBoundary</span><span class=\"p\">()</span><span class=\"si\">}</span><span class=\"p\">&gt;</span>Try again<span class=\"p\">&lt;/</span><span class=\"nc\">Button</span><span class=\"p\">&gt;</span>        <span class=\"p\">&lt;/</span><span class=\"nt\">div</span><span class=\"p\">&gt;</span>      <span class=\"p\">)</span><span class=\"si\">}</span>    <span class=\"p\">&gt;</span>      <span class=\"p\">&lt;</span><span class=\"nc\">Page</span> <span class=\"p\">/&gt;</span>    <span class=\"p\">&lt;/</span><span class=\"nc\">ErrorBoundary</span><span class=\"p\">&gt;</span>  <span class=\"p\">);</span><span class=\"p\">};</span></code></pre></div>    </div>  </li>  <li>깨끗한 코드는 읽기도 좋아야 하지만 안정성도 높아야한다는 말에 핵공감이다. 코드가 아무리 깨끗해도 버그가 많이 발생하는 코드라면 깨끗한 코드도 의미가 없어진다.</li></ul><p><strong>궁금한 내용이 있거나, 잘 이해되지 않는 내용이 있다면 적어보세요.</strong></p><ul>  <li>javascript 오류처리에 대한 좋은 글들이 많아 아래 링크로 걸어둔다.    <ul>      <li><a href=\"https://soobakba.tistory.com/43\">[JS] try…catch 그리고 에러 핸들링</a></li>    </ul>  </li>  <li><a href=\"https://github.com/qkraudghgh/clean-code-javascript-ko#%EC%97%90%EB%9F%AC-%EC%B2%98%EB%A6%ACerror-handling\">Clean Code concepts adapted for JavaScript</a> - 한글 번역판의 에러처리 부분을 가져온 내용이다.    <ul>      <li>try/catch로 어떤 코드를 감쌌다면 그에 대한 계획이 있거나 어떠한 장치를 해야한다.</li>    </ul>  </li></ul><p>안 좋은 예)</p><div class=\"language-jsx highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">try</span> <span class=\"p\">{</span>  <span class=\"nx\">functionThatMightThrow</span><span class=\"p\">();</span><span class=\"p\">}</span> <span class=\"k\">catch</span> <span class=\"p\">(</span><span class=\"nx\">error</span><span class=\"p\">)</span> <span class=\"p\">{</span>  <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"nx\">error</span><span class=\"p\">);</span><span class=\"p\">}</span></code></pre></div></div><p>좋은 예)</p><div class=\"language-jsx highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">try</span> <span class=\"p\">{</span>  <span class=\"nx\">functionThatMightThrow</span><span class=\"p\">();</span><span class=\"p\">}</span> <span class=\"k\">catch</span> <span class=\"p\">(</span><span class=\"nx\">error</span><span class=\"p\">)</span> <span class=\"p\">{</span>  <span class=\"c1\">// 첫번째 방법은 console.error를 이용하는 것입니다. 이건 console.log보다 조금 더 알아채기 쉽습니다.</span>  <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">error</span><span class=\"p\">(</span><span class=\"nx\">error</span><span class=\"p\">);</span>  <span class=\"c1\">// 다른 방법은 유저에게 알리는 방법입니다.</span>  <span class=\"nx\">notifyUserOfError</span><span class=\"p\">(</span><span class=\"nx\">error</span><span class=\"p\">);</span>  <span class=\"c1\">// 또 다른 방법은 서비스 자체에 에러를 기록하는 방법입니다.</span>  <span class=\"nx\">reportErrorToService</span><span class=\"p\">(</span><span class=\"nx\">error</span><span class=\"p\">);</span>  <span class=\"c1\">// 혹은 그 어떤 방법이 될 수 있습니다.</span><span class=\"p\">}</span></code></pre></div></div>",
            "url": "https://thehue.github.io/2022/05/05/til-%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C-7%EC%9E%A5-%EC%98%A4%EB%A5%98%EC%B2%98%EB%A6%AC",
            
            
            
            "tags": ["노마드코더","북클럽","노개북","노마드북클럽","코딩","개발자","TIL"],
            
            "date_published": "2022-05-05T00:00:00+09:00",
            "date_modified": "2022-05-05T00:00:00+09:00",
            
                "author":  {
                "name": "thehue",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://thehue.github.io/2022/05/04/til-%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C-6%EC%9E%A5-%EA%B0%9D%EC%B2%B4%EC%99%80-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0",
            "title": "TIL 클린코드 - 6장. 객체와 자료 구조",
            "summary": "책 클린코드 6장 형식 객체와 자료 구조 정리 및 느낌",
            "content_text": "TIL (Today I Learned)2022.05.04오늘 읽은 범위6장. 객체와 자료 구조책에서 기억하고 싶은 내용을 써보세요.  변수를 비공개로 정의하는 이유는 남들이 변수에 의존하지 않게 만들고 싶어서다.  자료 추상화          변수를 private으로 선언하더라도 각 값마다 get함수와 set함수를 제공한다면 구현을 외부로 노출하는 셈이다.      변수 사이에 함수라는 계층을 넣는다고 구현이 저절로 감춰지지는 않는다. 구현을 감추려면 추상화가 필요하다. 추상 인터페이스를 제공해 사용자가 구현을 모른 채 자료의 핵심을 조작할 수 있어야 진정한 의미의 클래스이다.      자료를 세세하게 공개하기 보다는 추상적인 개념으로 표현하는 편이 좋다.        자료/객체 비대칭          객체는 추상화 뒤로 자료를 숨긴 채 자료를 다루는 함수만 공개한다.      자료 구조는 자료를 그대로 공개하며 별다른 함수는 제공하지 않는다.      복잡한 시스템을 짜다 보면 새로운 함수가 아니라 새로운 자료 타입이 필요한 경우가 생긴다. 이때는 클래스와 객체 지향 기법이 가장 적합하다.      반면, 새로운 자료 타입이 아니라 새로운 함수가 필요한 경우도 생긴다. 이때는 절차적인 코드와 자료 구조가 좀 더 적합하다.            디미터 법칙          디미터 법칙은 잘 알려진 휴리스틱(직관적으로 판단)으로, 모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다는 법칙이다.              객체에서 허용된 메소드가 반환하는 객체의 메서드는 호출하면 안 된다.        // 나쁜 예 - 기차 충돌(train wreck)final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath();// 좋은 예Options opts = ctxt.getOptions();File scratchDir = opts.getScratchDir();final String ouputDir = scratchDir.getAbsolutePath();/*ctxt, Options, ScratchDir이 객체라면 내부 구조를 숨겨야 하므로 디미터 법칙을 위반하고,자료 구조라면 내부 구조를 노출하므로 디미터 법칙이 적용되지 않는다.*/// 더 좋은 예 - 조회 함수를 이용하지 않음final String outputDir = ctxt.options.scratchDir.absolutePath;                    ctxt가 객체라면 뭔가를 하라고 말해야지 속을 드러내라고 말하면 안 된다.        // 디미터 법칙을 위반하지 않는 좋은 예시BufferedOutputStream bos = ctxt.createScratchFileStream(classFileName);// 내부 구조를 드러내지 않으며 모듈에서 해당 함수는 자신이 몰라야 하는 여러 객체를 탐색할 필요가 없다        자료 전달 객체          자료 구조체의 전형적인 형태는 공개 변수만 있고 함수가 없는 클래스다. 이런 자료 구조체를 때로는 자료 전달 객체(Data Transfer Object, DTO)      데이터베이스와 통신하거나 소켓에서 받은 메시지의 구문을 분석할 때 유용하다.      활성 레코드                  활성 레코드는 DTO의 특수한 형태이다. 공개 변수가 있거나 비공개 변수에 조회/설정 함수가 있는 자료 구조지만, 대개 save나 find와 같은 탐색 함수도 제공한다. 활성 레코드는 데이터베이스 테이블이나 다른 소스에서 자료를 직접 변환한 결과다.                    오늘 읽은 소감은? 떠오르는 생각을 가볍게 적어보세요  예전에 잠깐 spring framework로 백엔드 API를 개발한 경험이 있는데, 객체와 자료 구조의 의미를 제대로 모르고 잡종 구조(절반은 객체, 절반은 자료구조)로 개발했던 것 같다.  자바 코드로 예시를 보여주고 있지만 기차 충돌 예시는 모든 코드에 적용되는 예시인 것 같다.  나는 주로 자바스크립트와 타입스크립트를 사용하기 때문에 Clean Code concepts adapted for JavaScript - 한글 번역판 을 보고 공부했고 아래 내용은 연관된 내용만 가져온 것이다.getter와 setter를 사용하세요JavaScript는 인터페이스와 타입을 가지고있지 않고 이러한 패턴을 적용하기가 힘듭니다. 왜냐하면 public이나 private같은 키워드가 없기 때문이죠. 그렇기 때문에 getter 및 setter를 사용하여 객체의 데이터에 접근하는 것이 객체의 속성을 찾는 것보다 훨씬 낫습니다. “왜요?”라고 물으실 수도 있겠습니다. 왜 그런지에 대해서 몇 가지 이유를 두서없이 적어봤습니다.  객체의 속성을 얻는 것 이상의 많은 것을 하고싶을 때, 코드에서 모든 접근자를 찾아 바꾸고 할 필요가 없습니다.  set할때 검증로직을 추가하는 것이 코드를 더 간단하게 만듭니다.  내부용 API를 캡슐화 할 수 있습니다.  getting과 setting할 때 로그를 찾거나 에러처리를 하기 쉽습니다.  서버에서 객체 속성을 받아올 때 lazy load 할 수 있습니다.안좋은 예:function makeBankAccount() {  // ...  return {    // ...    balance: 0,  };}const account = makeBankAccount();account.balance = 100;좋은 예:function makeBankAccount() {  // private으로 선언된 변수  let balance = 0;  // 아래 return을 통해 public으로 선언된 \"getter\"  function getBalance() {    return balance;  }  // 아래 return을 통해 public으로 선언된 \"setter\"  function setBalance(amount) {    // ... balance를 업데이트하기 전 검증로직    balance = amount;  }  return {    // ...    getBalance,    setBalance,  };}const account = makeBankAccount();account.setBalance(100);객체에 비공개 멤버를 만드세요클로저를 이용하면 가능합니다. (ES5 이하에서도)안좋은 예:const Employee = function (name) {  this.name = name;};Employee.prototype.getName = function getName() {  return this.name;};const employee = new Employee('John Doe');console.log(`Employee name: ${employee.getName()}`); // Employee name: John Doedelete employee.name;console.log(`Employee name: ${employee.getName()}`); // Employee name: undefined좋은 예:function makeEmployee(name) {  return {    getName() {      return name;    },  };}const employee = makeEmployee('John Doe');console.log(`Employee name: ${employee.getName()}`); // Employee name: John Doedelete employee.name;console.log(`Employee name: ${employee.getName()}`); // Employee name: John Doe",
            "content_html": "<p><strong>TIL (Today I Learned)</strong></p><p>2022.05.04</p><p><strong>오늘 읽은 범위</strong></p><p>6장. 객체와 자료 구조</p><p><strong>책에서 기억하고 싶은 내용을 써보세요.</strong></p><ul>  <li>변수를 비공개로 정의하는 이유는 남들이 변수에 의존하지 않게 만들고 싶어서다.</li>  <li>자료 추상화    <ul>      <li>변수를 private으로 선언하더라도 각 값마다 get함수와 set함수를 제공한다면 구현을 외부로 노출하는 셈이다.</li>      <li>변수 사이에 함수라는 계층을 넣는다고 구현이 저절로 감춰지지는 않는다. 구현을 감추려면 추상화가 필요하다. 추상 인터페이스를 제공해 사용자가 구현을 모른 채 자료의 핵심을 조작할 수 있어야 진정한 의미의 클래스이다.</li>      <li>자료를 세세하게 공개하기 보다는 추상적인 개념으로 표현하는 편이 좋다.</li>    </ul>  </li>  <li>자료/객체 비대칭    <ul>      <li>객체는 추상화 뒤로 자료를 숨긴 채 자료를 다루는 함수만 공개한다.</li>      <li>자료 구조는 자료를 그대로 공개하며 별다른 함수는 제공하지 않는다.</li>      <li>복잡한 시스템을 짜다 보면 새로운 함수가 아니라 새로운 자료 타입이 필요한 경우가 생긴다. 이때는 클래스와 객체 지향 기법이 가장 적합하다.</li>      <li>반면, 새로운 자료 타입이 아니라 새로운 함수가 필요한 경우도 생긴다. 이때는 절차적인 코드와 자료 구조가 좀 더 적합하다.</li>    </ul>  </li>  <li>    <p>디미터 법칙</p>    <ul>      <li>디미터 법칙은 잘 알려진 휴리스틱(직관적으로 판단)으로, 모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다는 법칙이다.</li>      <li>        <p>객체에서 허용된 메소드가 반환하는 객체의 메서드는 호출하면 안 된다.</p>        <div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 나쁜 예 - 기차 충돌(train wreck)</span><span class=\"kd\">final</span> <span class=\"nc\">String</span> <span class=\"n\">outputDir</span> <span class=\"o\">=</span> <span class=\"n\">ctxt</span><span class=\"o\">.</span><span class=\"na\">getOptions</span><span class=\"o\">().</span><span class=\"na\">getScratchDir</span><span class=\"o\">().</span><span class=\"na\">getAbsolutePath</span><span class=\"o\">();</span><span class=\"c1\">// 좋은 예</span><span class=\"nc\">Options</span> <span class=\"n\">opts</span> <span class=\"o\">=</span> <span class=\"n\">ctxt</span><span class=\"o\">.</span><span class=\"na\">getOptions</span><span class=\"o\">();</span><span class=\"nc\">File</span> <span class=\"n\">scratchDir</span> <span class=\"o\">=</span> <span class=\"n\">opts</span><span class=\"o\">.</span><span class=\"na\">getScratchDir</span><span class=\"o\">();</span><span class=\"kd\">final</span> <span class=\"nc\">String</span> <span class=\"n\">ouputDir</span> <span class=\"o\">=</span> <span class=\"n\">scratchDir</span><span class=\"o\">.</span><span class=\"na\">getAbsolutePath</span><span class=\"o\">();</span><span class=\"cm\">/*ctxt, Options, ScratchDir이 객체라면 내부 구조를 숨겨야 하므로 디미터 법칙을 위반하고,자료 구조라면 내부 구조를 노출하므로 디미터 법칙이 적용되지 않는다.*/</span><span class=\"c1\">// 더 좋은 예 - 조회 함수를 이용하지 않음</span><span class=\"kd\">final</span> <span class=\"nc\">String</span> <span class=\"n\">outputDir</span> <span class=\"o\">=</span> <span class=\"n\">ctxt</span><span class=\"o\">.</span><span class=\"na\">options</span><span class=\"o\">.</span><span class=\"na\">scratchDir</span><span class=\"o\">.</span><span class=\"na\">absolutePath</span><span class=\"o\">;</span></code></pre></div>        </div>      </li>      <li>ctxt가 객체라면 뭔가를 하라고 말해야지 속을 드러내라고 말하면 안 된다.</li>    </ul>    <div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 디미터 법칙을 위반하지 않는 좋은 예시</span><span class=\"nc\">BufferedOutputStream</span> <span class=\"n\">bos</span> <span class=\"o\">=</span> <span class=\"n\">ctxt</span><span class=\"o\">.</span><span class=\"na\">createScratchFileStream</span><span class=\"o\">(</span><span class=\"n\">classFileName</span><span class=\"o\">);</span><span class=\"c1\">// 내부 구조를 드러내지 않으며 모듈에서 해당 함수는 자신이 몰라야 하는 여러 객체를 탐색할 필요가 없다</span></code></pre></div>    </div>  </li>  <li>자료 전달 객체    <ul>      <li>자료 구조체의 전형적인 형태는 공개 변수만 있고 함수가 없는 클래스다. 이런 자료 구조체를 때로는 자료 전달 객체(Data Transfer Object, DTO)</li>      <li>데이터베이스와 통신하거나 소켓에서 받은 메시지의 구문을 분석할 때 유용하다.</li>      <li>활성 레코드        <ul>          <li>활성 레코드는 DTO의 특수한 형태이다. 공개 변수가 있거나 비공개 변수에 조회/설정 함수가 있는 자료 구조지만, 대개 save나 find와 같은 탐색 함수도 제공한다. 활성 레코드는 데이터베이스 테이블이나 다른 소스에서 자료를 직접 변환한 결과다.</li>        </ul>      </li>    </ul>  </li></ul><p><strong>오늘 읽은 소감은? 떠오르는 생각을 가볍게 적어보세요</strong></p><ul>  <li>예전에 잠깐 spring framework로 백엔드 API를 개발한 경험이 있는데, 객체와 자료 구조의 의미를 제대로 모르고 잡종 구조(절반은 객체, 절반은 자료구조)로 개발했던 것 같다.</li>  <li>자바 코드로 예시를 보여주고 있지만 기차 충돌 예시는 모든 코드에 적용되는 예시인 것 같다.</li>  <li>나는 주로 자바스크립트와 타입스크립트를 사용하기 때문에 <a href=\"https://github.com/qkraudghgh/clean-code-javascript-ko\">Clean Code concepts adapted for JavaScript - 한글 번역판</a> 을 보고 공부했고 아래 내용은 연관된 내용만 가져온 것이다.</li></ul><hr /><p><strong>getter와 setter를 사용하세요</strong></p><p>JavaScript는 인터페이스와 타입을 가지고있지 않고 이러한 패턴을 적용하기가 힘듭니다. 왜냐하면 <code class=\"language-plaintext highlighter-rouge\">public</code>이나 <code class=\"language-plaintext highlighter-rouge\">private</code>같은 키워드가 없기 때문이죠. 그렇기 때문에 getter 및 setter를 사용하여 객체의 데이터에 접근하는 것이 객체의 속성을 찾는 것보다 훨씬 낫습니다. “왜요?”라고 물으실 수도 있겠습니다. 왜 그런지에 대해서 몇 가지 이유를 두서없이 적어봤습니다.</p><ul>  <li>객체의 속성을 얻는 것 이상의 많은 것을 하고싶을 때, 코드에서 모든 <a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions/get\"><code class=\"language-plaintext highlighter-rouge\">접근자</code></a>를 찾아 바꾸고 할 필요가 없습니다.</li>  <li><code class=\"language-plaintext highlighter-rouge\">set</code>할때 검증로직을 추가하는 것이 코드를 더 간단하게 만듭니다.</li>  <li>내부용 API를 캡슐화 할 수 있습니다.</li>  <li><code class=\"language-plaintext highlighter-rouge\">getting</code>과 <code class=\"language-plaintext highlighter-rouge\">setting</code>할 때 로그를 찾거나 에러처리를 하기 쉽습니다.</li>  <li>서버에서 객체 속성을 받아올 때 lazy load 할 수 있습니다.</li></ul><p><strong>안좋은 예:</strong></p><div class=\"language-jsx highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">function</span> <span class=\"nx\">makeBankAccount</span><span class=\"p\">()</span> <span class=\"p\">{</span>  <span class=\"c1\">// ...</span>  <span class=\"k\">return</span> <span class=\"p\">{</span>    <span class=\"c1\">// ...</span>    <span class=\"na\">balance</span><span class=\"p\">:</span> <span class=\"mi\">0</span><span class=\"p\">,</span>  <span class=\"p\">};</span><span class=\"p\">}</span><span class=\"kd\">const</span> <span class=\"nx\">account</span> <span class=\"o\">=</span> <span class=\"nx\">makeBankAccount</span><span class=\"p\">();</span><span class=\"nx\">account</span><span class=\"p\">.</span><span class=\"nx\">balance</span> <span class=\"o\">=</span> <span class=\"mi\">100</span><span class=\"p\">;</span></code></pre></div></div><p><strong>좋은 예:</strong></p><div class=\"language-jsx highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">function</span> <span class=\"nx\">makeBankAccount</span><span class=\"p\">()</span> <span class=\"p\">{</span>  <span class=\"c1\">// private으로 선언된 변수</span>  <span class=\"kd\">let</span> <span class=\"nx\">balance</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>  <span class=\"c1\">// 아래 return을 통해 public으로 선언된 \"getter\"</span>  <span class=\"kd\">function</span> <span class=\"nx\">getBalance</span><span class=\"p\">()</span> <span class=\"p\">{</span>    <span class=\"k\">return</span> <span class=\"nx\">balance</span><span class=\"p\">;</span>  <span class=\"p\">}</span>  <span class=\"c1\">// 아래 return을 통해 public으로 선언된 \"setter\"</span>  <span class=\"kd\">function</span> <span class=\"nx\">setBalance</span><span class=\"p\">(</span><span class=\"nx\">amount</span><span class=\"p\">)</span> <span class=\"p\">{</span>    <span class=\"c1\">// ... balance를 업데이트하기 전 검증로직</span>    <span class=\"nx\">balance</span> <span class=\"o\">=</span> <span class=\"nx\">amount</span><span class=\"p\">;</span>  <span class=\"p\">}</span>  <span class=\"k\">return</span> <span class=\"p\">{</span>    <span class=\"c1\">// ...</span>    <span class=\"nx\">getBalance</span><span class=\"p\">,</span>    <span class=\"nx\">setBalance</span><span class=\"p\">,</span>  <span class=\"p\">};</span><span class=\"p\">}</span><span class=\"kd\">const</span> <span class=\"nx\">account</span> <span class=\"o\">=</span> <span class=\"nx\">makeBankAccount</span><span class=\"p\">();</span><span class=\"nx\">account</span><span class=\"p\">.</span><span class=\"nx\">setBalance</span><span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">);</span></code></pre></div></div><p><strong>객체에 비공개 멤버를 만드세요</strong></p><p><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Closures\">클로저</a>를 이용하면 가능합니다. (ES5 이하에서도)</p><p><strong>안좋은 예:</strong></p><div class=\"language-jsx highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">const</span> <span class=\"nx\">Employee</span> <span class=\"o\">=</span> <span class=\"kd\">function</span> <span class=\"p\">(</span><span class=\"nx\">name</span><span class=\"p\">)</span> <span class=\"p\">{</span>  <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">name</span> <span class=\"o\">=</span> <span class=\"nx\">name</span><span class=\"p\">;</span><span class=\"p\">};</span><span class=\"nx\">Employee</span><span class=\"p\">.</span><span class=\"nx\">prototype</span><span class=\"p\">.</span><span class=\"nx\">getName</span> <span class=\"o\">=</span> <span class=\"kd\">function</span> <span class=\"nx\">getName</span><span class=\"p\">()</span> <span class=\"p\">{</span>  <span class=\"k\">return</span> <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">name</span><span class=\"p\">;</span><span class=\"p\">};</span><span class=\"kd\">const</span> <span class=\"nx\">employee</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">Employee</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">John Doe</span><span class=\"dl\">'</span><span class=\"p\">);</span><span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s2\">`Employee name: </span><span class=\"p\">${</span><span class=\"nx\">employee</span><span class=\"p\">.</span><span class=\"nx\">getName</span><span class=\"p\">()}</span><span class=\"s2\">`</span><span class=\"p\">);</span> <span class=\"c1\">// Employee name: John Doe</span><span class=\"k\">delete</span> <span class=\"nx\">employee</span><span class=\"p\">.</span><span class=\"nx\">name</span><span class=\"p\">;</span><span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s2\">`Employee name: </span><span class=\"p\">${</span><span class=\"nx\">employee</span><span class=\"p\">.</span><span class=\"nx\">getName</span><span class=\"p\">()}</span><span class=\"s2\">`</span><span class=\"p\">);</span> <span class=\"c1\">// Employee name: undefined</span></code></pre></div></div><p><strong>좋은 예:</strong></p><div class=\"language-jsx highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">function</span> <span class=\"nx\">makeEmployee</span><span class=\"p\">(</span><span class=\"nx\">name</span><span class=\"p\">)</span> <span class=\"p\">{</span>  <span class=\"k\">return</span> <span class=\"p\">{</span>    <span class=\"nx\">getName</span><span class=\"p\">()</span> <span class=\"p\">{</span>      <span class=\"k\">return</span> <span class=\"nx\">name</span><span class=\"p\">;</span>    <span class=\"p\">},</span>  <span class=\"p\">};</span><span class=\"p\">}</span><span class=\"kd\">const</span> <span class=\"nx\">employee</span> <span class=\"o\">=</span> <span class=\"nx\">makeEmployee</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">John Doe</span><span class=\"dl\">'</span><span class=\"p\">);</span><span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s2\">`Employee name: </span><span class=\"p\">${</span><span class=\"nx\">employee</span><span class=\"p\">.</span><span class=\"nx\">getName</span><span class=\"p\">()}</span><span class=\"s2\">`</span><span class=\"p\">);</span> <span class=\"c1\">// Employee name: John Doe</span><span class=\"k\">delete</span> <span class=\"nx\">employee</span><span class=\"p\">.</span><span class=\"nx\">name</span><span class=\"p\">;</span><span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s2\">`Employee name: </span><span class=\"p\">${</span><span class=\"nx\">employee</span><span class=\"p\">.</span><span class=\"nx\">getName</span><span class=\"p\">()}</span><span class=\"s2\">`</span><span class=\"p\">);</span> <span class=\"c1\">// Employee name: John Doe</span></code></pre></div></div>",
            "url": "https://thehue.github.io/2022/05/04/til-%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C-6%EC%9E%A5-%EA%B0%9D%EC%B2%B4%EC%99%80-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0",
            
            
            
            "tags": ["노마드코더","북클럽","노개북","노마드북클럽","코딩","개발자","TIL"],
            
            "date_published": "2022-05-04T00:00:00+09:00",
            "date_modified": "2022-05-04T00:00:00+09:00",
            
                "author":  {
                "name": "thehue",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://thehue.github.io/2022/05/02/til-%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C-5%EC%9E%A5-%ED%98%95%EC%8B%9D",
            "title": "TIL 클린코드 - 5장. 형식 맞추기",
            "summary": "책 클린코드 5장 형식 맞추기 정리 및 느낌",
            "content_text": "TIL (Today I Learned)2022.05.02오늘 읽은 범위5장. 형식 맞추기책에서 기억하고 싶은 내용을 써보세요.  형식을 맞추는 목적          코드 형식은 의사소통의 일환이다. 의사소통은 전문 개발자의 일차적인 의무이다.      오랜 시간이 지나 원래 코드의 흔적을 더 이상 찾아보기 어려울 정도로 코드가 바뀌어도 맨 처음 잡아 놓은 구현 스타일과 가독성 수준은 유지보수 용이성과 확장성에 계속 영향을 미친다.        신문 기사처럼 작성하라          소스파일의 이름은 이름만 보고도 올바른 모듈을 살펴보고 있는지 아닌지를 판단할 정도로 신경 써서 짓는다.      소스파일 첫 부분은 고차원 개념과 알고리즘을 설명한다. 아래로 내려갈수록 의도를 세세하게 묘사한다.      마지막에는 가장 저차원 함수와 세부 내역이 나온다.        개념은 빈 행으로 분리하라          빈 행은 새로운 개념을 시작한다는 시각적 단서다.        세로 밀집도          세로 밀집도는 연관성을 의미한다. 서로 밀접한 코드 행은 세로로 가까이 놓여야 한다는 뜻이다.        수직 거리          같은 파일에 속할 정도로 밀접한 두 개념은 세로 거리로 연관성을 표현한다.        변수 선언          변수는 사용하는 위치에 최대한 가까이 선언한다. 지역 변수는 각 함수 맨 처음에 선언한다.      루프를 제어하는 변수는 루프 문 내부에 선언한다.      아주 드물지만 다소 긴 함수에서 블록 상단이나 루프 직전에 변수를 선언하는 사례도 있다.        인스턴스 변수          인스턴스 변수는 클래스 맨 처음에 선언한다. 변수 간에 세로로 거리를 두지 않는다. 잘 설계한 클래스는 많은 클래스 메서드가 인스턴트 변수를 사용하기 때문이다.        종속 변수          한 함수가 다른 함수를 호출한다면 두 함수는 세로로 가까이 배치한다. 또한 가능하다면 호출하는 함수를 호출되는 함수보다 먼저 배치한다.        세로 순서          호출되는 함수를 호출하는 함수보다 나중에 배치한다. 그러면 소스 코드 모듈이 고차원에서 저차원으로 자연스럽게 내려간다.      오늘 읽은 소감은? 떠오르는 생각을 가볍게 적어보세요  책의 형식을 지키지 않은 예시를 보면서 코드 형식을 지키는 것이 가독성에 많은 영향을 끼친다는 것을 더 체감할 수 있었다.  javascript 개발의 경우 prettier로 자동 formatting을 해주는데 오늘 다양한 예제를 보면서 prettier를 개발한 개발자에게 감사함을 느꼈다.🙏🏻  책에서 특히 공감 됐던 구절은 ‘팀에 속한다면 자신이 선호해야 할 규칙은 바로 팀 규칙이다’ 이다. 전에 있었던 회사의 개발자 분이 코드를 리뷰 해주시면서 전체 코드가 마치 한 사람이 작성한 것처럼 코드를 작성해야한다고 말씀해주셨던 기억이 난다.궁금한 내용이 있거나, 잘 이해되지 않는 내용이 있다면 적어보세요.  일반적으로 C++ 에서는 모든 인스턴스 변수를 클래스 마지막에 선언한다는 소위 가위 규칙을 적용한다.          가위 규칙 어렵다..🥲      ",
            "content_html": "<p><strong>TIL (Today I Learned)</strong></p><p>2022.05.02</p><p><strong>오늘 읽은 범위</strong></p><p>5장. 형식 맞추기</p><p><strong>책에서 기억하고 싶은 내용을 써보세요.</strong></p><ul>  <li><strong>형식을 맞추는 목적</strong>    <ul>      <li>코드 형식은 의사소통의 일환이다. 의사소통은 전문 개발자의 일차적인 의무이다.</li>      <li>오랜 시간이 지나 원래 코드의 흔적을 더 이상 찾아보기 어려울 정도로 코드가 바뀌어도 맨 처음 잡아 놓은 구현 스타일과 가독성 수준은 유지보수 용이성과 확장성에 계속 영향을 미친다.</li>    </ul>  </li>  <li><strong>신문 기사처럼 작성하라</strong>    <ul>      <li>소스파일의 이름은 이름만 보고도 올바른 모듈을 살펴보고 있는지 아닌지를 판단할 정도로 신경 써서 짓는다.</li>      <li>소스파일 첫 부분은 <a href=\"https://developer-talk.tistory.com/162\">고차원 개념</a>과 알고리즘을 설명한다. 아래로 내려갈수록 의도를 세세하게 묘사한다.</li>      <li>마지막에는 가장 저차원 함수와 세부 내역이 나온다.</li>    </ul>  </li>  <li><strong>개념은 빈 행으로 분리하라</strong>    <ul>      <li>빈 행은 새로운 개념을 시작한다는 시각적 단서다.</li>    </ul>  </li>  <li><strong>세로 밀집도</strong>    <ul>      <li>세로 밀집도는 연관성을 의미한다. 서로 밀접한 코드 행은 세로로 가까이 놓여야 한다는 뜻이다.</li>    </ul>  </li>  <li><strong>수직 거리</strong>    <ul>      <li>같은 파일에 속할 정도로 밀접한 두 개념은 세로 거리로 연관성을 표현한다.</li>    </ul>  </li>  <li><strong>변수 선언</strong>    <ul>      <li>변수는 사용하는 위치에 최대한 가까이 선언한다. 지역 변수는 각 함수 맨 처음에 선언한다.</li>      <li>루프를 제어하는 변수는 루프 문 내부에 선언한다.</li>      <li>아주 드물지만 다소 긴 함수에서 블록 상단이나 루프 직전에 변수를 선언하는 사례도 있다.</li>    </ul>  </li>  <li><strong>인스턴스 변수</strong>    <ul>      <li><a href=\"https://ko.wikipedia.org/wiki/%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4_%EB%B3%80%EC%88%98\">인스턴스 변수</a>는 클래스 맨 처음에 선언한다. 변수 간에 세로로 거리를 두지 않는다. 잘 설계한 클래스는 많은 클래스 메서드가 인스턴트 변수를 사용하기 때문이다.</li>    </ul>  </li>  <li><strong>종속 변수</strong>    <ul>      <li>한 함수가 다른 함수를 호출한다면 두 함수는 세로로 가까이 배치한다. 또한 가능하다면 호출하는 함수를 호출되는 함수보다 먼저 배치한다.</li>    </ul>  </li>  <li><strong>세로 순서</strong>    <ul>      <li>호출되는 함수를 호출하는 함수보다 나중에 배치한다. 그러면 소스 코드 모듈이 고차원에서 저차원으로 자연스럽게 내려간다.</li>    </ul>  </li></ul><p><strong>오늘 읽은 소감은? 떠오르는 생각을 가볍게 적어보세요</strong></p><ul>  <li>책의 형식을 지키지 않은 예시를 보면서 코드 형식을 지키는 것이 가독성에 많은 영향을 끼친다는 것을 더 체감할 수 있었다.</li>  <li>javascript 개발의 경우 prettier로 자동 formatting을 해주는데 오늘 다양한 예제를 보면서 prettier를 개발한 개발자에게 감사함을 느꼈다.🙏🏻</li>  <li>책에서 특히 공감 됐던 구절은 <em>‘팀에 속한다면 자신이 선호해야 할 규칙은 바로 팀 규칙이다’</em> 이다. 전에 있었던 회사의 개발자 분이 코드를 리뷰 해주시면서 전체 코드가 마치 한 사람이 작성한 것처럼 코드를 작성해야한다고 말씀해주셨던 기억이 난다.</li></ul><p><strong>궁금한 내용이 있거나, 잘 이해되지 않는 내용이 있다면 적어보세요.</strong></p><ul>  <li>일반적으로 C++ 에서는 모든 인스턴스 변수를 클래스 마지막에 선언한다는 소위 가위 규칙을 적용한다.    <ul>      <li>가위 규칙 어렵다..🥲</li>    </ul>  </li></ul>",
            "url": "https://thehue.github.io/2022/05/02/til-%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C-5%EC%9E%A5-%ED%98%95%EC%8B%9D",
            
            
            
            "tags": ["노마드코더","북클럽","노개북","노마드북클럽","코딩","개발자","TIL"],
            
            "date_published": "2022-05-02T00:00:00+09:00",
            "date_modified": "2022-05-02T00:00:00+09:00",
            
                "author":  {
                "name": "thehue",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://thehue.github.io/2022/04/29/til-%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C-4%EC%9E%A5-%EC%A3%BC%EC%84%9D",
            "title": "TIL 클린코드 - 4장. 주석",
            "summary": "책 클린코드 4장 주석",
            "content_text": "TIL (Today I Learned)2022.04.29오늘 읽은 범위4장. 주석책에서 기억하고 싶은 내용을 써보세요.  주석은 언제나 실패를 의미한다. 때때로 주석 없이는 자신을 표현할 방법을 찾지 못해 할 수 없이 주석을 사용한다. 코드로 의도를 표현할 방법은 없을까?(p.68)  표현력이 풍부하고 깔끔하며 주석이 거의 없는 코드가, 복잡하고 어수선하며 주석이 많이 달린 코드보다 훨신 좋다. 자신이 저지른 난장판을 주석으로 설명하려 애쓰는 대신에 그 난장판을 깨끗이 치우는 데 시간을 보내라!(p.69)      다음 코드 예제 두 개를 살펴보자. 어느 쪽이 더 나은가? (p.70)    // 직원에게 복지 혜택을 받을 자격이 있는지 검사한다.if ((employee.flags &amp; HOURLY_FLAG) &amp;&amp; (employee.age &gt; 65))        다음 코드는 어떤가?    if (employee.isEligibleForFullBenefits())        법적인 주석 - 각 소스 파일 첫머리에 주석으로 들어가는 저작권 정보와 소유권 정보는 필요하고도 타당하다. (p.70)  정보를 제공하는 주석 - 함수 이름에 정보를 담는 편이 좋다.  의도를 설명하는 주석 - 때때로 주석은 구현을 이해하게 도와주는 선을 넘어 결정에 깔린 의도까지 설명한다.  의미를 명료하게 밝히는 주석 - 일반적으로는 인수나 반환값 자체를 명확하게 만들면 더 좋겠지만, 인수나 반환값이 표준 라이브러리나 변경하지 못하는 코드에 속한다면 의미를 명료하게 밝히는 주석이 유용하다.  결과를 경고하는 주석 - ex) 특정 테스트 케이스를 꺼야 하는 이유를 설명하는 주석// 여유 시간이 충분하지 않다면 실행하지 마십시오.public void _testWithReallyBigFile(){\twriteLinesToFile(1000000);\t...}public static SimpleDateFormat makeStandardHttpDateFormat(){\t// SimpleDateFormat은 스레드에 안전하지 못하다.\t// 따라서 각 인스턴스를 독립적으로 생성해야 한다.\tSimpleDateFormat df = new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss z\");\tdf.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\treturn df;}  TODO 주석 - ‘앞으로 할 일’을 // TODO 주석으로 남겨두면 편하다.// TODO-MdM 현재 필요하지 않다.// 체크아웃 모델을 도입하면 함수가 필요 없다.protected VersionInfo makeVersion() throws Exception{\treturn null;}  중요성을 강조하는 주석String listItemContent = match.group(3).trim();// 여기서 trim은 정말 중요하다. trim 함수는 문자열에서 시작 공백을 제거한다.// 문자열에 시작 공백이 있으면 다른 문자열로 인식되기 때문이다.  주절거리는 주석 - 특별한 이유 없이 의무감으로 혹은 프로세스에서 하라고 하니까 마지못해 주석을 단다면 전적으로 시간낭비다. 주석을 달기로 결정했다면 충분한 시간을 들여 최고의 주석을 달도록 한다.  의무적으로 다는 주석 - 모든 함수에 Javadocs를 달거나 모든 변수에 주석을 달아야 한다는 규칙은 어리석기 그지없다.  함수나 변수로 표현할 수 있다면 주석을 달지 마라  닫는 괄호에 다는 주석 - 닫는 괄호에 주석을 달아야겠다는 생각이 든다면 대신에 함수를 줄이려 시도하자.  공로를 돌리거나 저자를 표시하는 주석 - 소스 코드 관리 시스템은 누가 언제 무엇을 추가했는지 귀신처럼 기억한다. 저자 이름으로 코드를 오염시킬 필요가 없다.  주석으로 처리한 코드 - 주석으로 처리된 코드는 다른 사람들이 지우기를 주저한다. 그래서 질 나쁜 와인병 바닥에 앙금이 쌓이듯 쓸모 없는 코드가 점차 쌓여간다.  전역 정보 - 주석을 달아야 한다면 근처에 있는 코드만 기술하라. 함수 자체는 포트 기본값을 전혀 통제하지 못한다. 즉, 포트 기본값을 설정하는 코드가 변해도 아래 주석이 변하리라는 보장은 전혀 없다./*** 적합성 테스트가 동작하는 포트: 기본값은 &lt;b&gt;8082&lt;/b&gt;** @param fitnessPort*/public void setFitnessPort(int fitnessPort){\tthis.fitnessePort = fitnessePort;}오늘 읽은 소감은? 떠오르는 생각을 가볍게 적어보세요  이번 장을 읽으면서 얼마나 찔렸는지 모른다. 가장 찔렸던 부분은 의무적으로 다는 주석과 중복되는 주석! 혹시나 내 코드를 이해하지 못할까봐 의무적으로 달았던 주석이 많았는데 저자의 말이 맞는 것 같다. 이해할 수 없게 코드를 짰기 때문에 주석을 다는 것이라고!  주석을 어떻게 달까 고민하는 시간도 많았는데 주석이 필요 없는 방향으로 변수명과 함수명을 짓는데 더 많은 시간을 쏟아야겠다.  보통 글을 작성할 때 여러번 다듬고 이 말을 여기에 써도 되는가를 고민하게 된다. 왜냐면 남들이 읽기 때문이다! 코드나 주석을 작성하는 것도 결국은 기록이 남고 남들이 읽는데 왜 신중하지 않게 작성했지?라는 생각이 든다. 주석 하나도 고민하면서 남기자.궁금한 내용이 있거나, 잘 이해되지 않는 내용이 있다면 적어보세요.  이번 장은 이해가 잘됐다! 😁",
            "content_html": "<p><strong>TIL (Today I Learned)</strong></p><p>2022.04.29</p><p><strong>오늘 읽은 범위</strong></p><p>4장. 주석</p><p><strong>책에서 기억하고 싶은 내용을 써보세요.</strong></p><ul>  <li>주석은 언제나 실패를 의미한다. 때때로 주석 없이는 자신을 표현할 방법을 찾지 못해 할 수 없이 주석을 사용한다. 코드로 의도를 표현할 방법은 없을까?(p.68)</li>  <li>표현력이 풍부하고 깔끔하며 주석이 거의 없는 코드가, 복잡하고 어수선하며 주석이 많이 달린 코드보다 훨신 좋다. 자신이 저지른 난장판을 주석으로 설명하려 애쓰는 대신에 그 난장판을 깨끗이 치우는 데 시간을 보내라!(p.69)</li>  <li>    <p>다음 코드 예제 두 개를 살펴보자. 어느 쪽이 더 나은가? (p.70)</p>    <div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 직원에게 복지 혜택을 받을 자격이 있는지 검사한다.</span><span class=\"k\">if</span> <span class=\"o\">((</span><span class=\"n\">employee</span><span class=\"o\">.</span><span class=\"na\">flags</span> <span class=\"o\">&amp;</span> <span class=\"no\">HOURLY_FLAG</span><span class=\"o\">)</span> <span class=\"o\">&amp;&amp;</span> <span class=\"o\">(</span><span class=\"n\">employee</span><span class=\"o\">.</span><span class=\"na\">age</span> <span class=\"o\">&gt;</span> <span class=\"mi\">65</span><span class=\"o\">))</span></code></pre></div>    </div>    <p>다음 코드는 어떤가?</p>    <div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">employee</span><span class=\"o\">.</span><span class=\"na\">isEligibleForFullBenefits</span><span class=\"o\">())</span></code></pre></div>    </div>  </li>  <li>법적인 주석 - 각 소스 파일 첫머리에 주석으로 들어가는 저작권 정보와 소유권 정보는 필요하고도 타당하다. (p.70)</li>  <li>정보를 제공하는 주석 - 함수 이름에 정보를 담는 편이 좋다.</li>  <li>의도를 설명하는 주석 - 때때로 주석은 구현을 이해하게 도와주는 선을 넘어 결정에 깔린 의도까지 설명한다.</li>  <li>의미를 명료하게 밝히는 주석 - 일반적으로는 인수나 반환값 자체를 명확하게 만들면 더 좋겠지만, 인수나 반환값이 표준 라이브러리나 변경하지 못하는 코드에 속한다면 의미를 명료하게 밝히는 주석이 유용하다.</li>  <li>결과를 경고하는 주석 - ex) 특정 테스트 케이스를 꺼야 하는 이유를 설명하는 주석</li></ul><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 여유 시간이 충분하지 않다면 실행하지 마십시오.</span><span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">_testWithReallyBigFile</span><span class=\"o\">()</span><span class=\"o\">{</span>\t<span class=\"n\">writeLinesToFile</span><span class=\"o\">(</span><span class=\"mi\">1000000</span><span class=\"o\">);</span>\t<span class=\"o\">...</span><span class=\"o\">}</span><span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"nc\">SimpleDateFormat</span> <span class=\"nf\">makeStandardHttpDateFormat</span><span class=\"o\">()</span><span class=\"o\">{</span>\t<span class=\"c1\">// SimpleDateFormat은 스레드에 안전하지 못하다.</span>\t<span class=\"c1\">// 따라서 각 인스턴스를 독립적으로 생성해야 한다.</span>\t<span class=\"nc\">SimpleDateFormat</span> <span class=\"n\">df</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">SimpleDateFormat</span><span class=\"o\">(</span><span class=\"s\">\"EEE, dd MMM yyyy HH:mm:ss z\"</span><span class=\"o\">);</span>\t<span class=\"n\">df</span><span class=\"o\">.</span><span class=\"na\">setTimeZone</span><span class=\"o\">(</span><span class=\"nc\">TimeZone</span><span class=\"o\">.</span><span class=\"na\">getTimeZone</span><span class=\"o\">(</span><span class=\"s\">\"GMT\"</span><span class=\"o\">));</span>\t<span class=\"k\">return</span> <span class=\"n\">df</span><span class=\"o\">;</span><span class=\"o\">}</span></code></pre></div></div><ul>  <li>TODO 주석 - ‘앞으로 할 일’을 // TODO 주석으로 남겨두면 편하다.</li></ul><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// TODO-MdM 현재 필요하지 않다.</span><span class=\"c1\">// 체크아웃 모델을 도입하면 함수가 필요 없다.</span><span class=\"kd\">protected</span> <span class=\"nc\">VersionInfo</span> <span class=\"nf\">makeVersion</span><span class=\"o\">()</span> <span class=\"kd\">throws</span> <span class=\"nc\">Exception</span><span class=\"o\">{</span>\t<span class=\"k\">return</span> <span class=\"kc\">null</span><span class=\"o\">;</span><span class=\"o\">}</span></code></pre></div></div><ul>  <li>중요성을 강조하는 주석</li></ul><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">String</span> <span class=\"n\">listItemContent</span> <span class=\"o\">=</span> <span class=\"n\">match</span><span class=\"o\">.</span><span class=\"na\">group</span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">).</span><span class=\"na\">trim</span><span class=\"o\">();</span><span class=\"c1\">// 여기서 trim은 정말 중요하다. trim 함수는 문자열에서 시작 공백을 제거한다.</span><span class=\"c1\">// 문자열에 시작 공백이 있으면 다른 문자열로 인식되기 때문이다.</span></code></pre></div></div><ul>  <li>주절거리는 주석 - 특별한 이유 없이 의무감으로 혹은 프로세스에서 하라고 하니까 마지못해 주석을 단다면 전적으로 시간낭비다. 주석을 달기로 결정했다면 충분한 시간을 들여 최고의 주석을 달도록 한다.</li>  <li>의무적으로 다는 주석 - 모든 함수에 Javadocs를 달거나 모든 변수에 주석을 달아야 한다는 규칙은 어리석기 그지없다.</li>  <li>함수나 변수로 표현할 수 있다면 주석을 달지 마라</li>  <li>닫는 괄호에 다는 주석 - 닫는 괄호에 주석을 달아야겠다는 생각이 든다면 대신에 함수를 줄이려 시도하자.</li>  <li>공로를 돌리거나 저자를 표시하는 주석 - 소스 코드 관리 시스템은 누가 언제 무엇을 추가했는지 귀신처럼 기억한다. 저자 이름으로 코드를 오염시킬 필요가 없다.</li>  <li>주석으로 처리한 코드 - 주석으로 처리된 코드는 다른 사람들이 지우기를 주저한다. 그래서 질 나쁜 와인병 바닥에 앙금이 쌓이듯 쓸모 없는 코드가 점차 쌓여간다.</li>  <li>전역 정보 - 주석을 달아야 한다면 근처에 있는 코드만 기술하라. 함수 자체는 포트 기본값을 전혀 통제하지 못한다. 즉, 포트 기본값을 설정하는 코드가 변해도 아래 주석이 변하리라는 보장은 전혀 없다.</li></ul><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"cm\">/*** 적합성 테스트가 동작하는 포트: 기본값은 &lt;b&gt;8082&lt;/b&gt;** @param fitnessPort*/</span><span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">setFitnessPort</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">fitnessPort</span><span class=\"o\">){</span>\t<span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">fitnessePort</span> <span class=\"o\">=</span> <span class=\"n\">fitnessePort</span><span class=\"o\">;</span><span class=\"o\">}</span></code></pre></div></div><p><strong>오늘 읽은 소감은? 떠오르는 생각을 가볍게 적어보세요</strong></p><ul>  <li>이번 장을 읽으면서 얼마나 찔렸는지 모른다. 가장 찔렸던 부분은 의무적으로 다는 주석과 중복되는 주석! 혹시나 내 코드를 이해하지 못할까봐 의무적으로 달았던 주석이 많았는데 저자의 말이 맞는 것 같다. 이해할 수 없게 코드를 짰기 때문에 주석을 다는 것이라고!</li>  <li>주석을 어떻게 달까 고민하는 시간도 많았는데 주석이 필요 없는 방향으로 변수명과 함수명을 짓는데 더 많은 시간을 쏟아야겠다.</li>  <li>보통 글을 작성할 때 여러번 다듬고 이 말을 여기에 써도 되는가를 고민하게 된다. 왜냐면 남들이 읽기 때문이다! 코드나 주석을 작성하는 것도 결국은 기록이 남고 남들이 읽는데 왜 신중하지 않게 작성했지?라는 생각이 든다. 주석 하나도 고민하면서 남기자.</li></ul><p><strong>궁금한 내용이 있거나, 잘 이해되지 않는 내용이 있다면 적어보세요.</strong></p><ul>  <li>이번 장은 이해가 잘됐다! 😁</li></ul>",
            "url": "https://thehue.github.io/2022/04/29/til-%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C-4%EC%9E%A5-%EC%A3%BC%EC%84%9D",
            
            
            
            "tags": ["노마드코더","북클럽","노개북","노마드북클럽","코딩","개발자","TIL"],
            
            "date_published": "2022-04-29T00:00:00+09:00",
            "date_modified": "2022-04-29T00:00:00+09:00",
            
                "author":  {
                "name": "thehue",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://thehue.github.io/2022/04/22/%EB%85%B8%EA%B0%9C%EB%B6%81-%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C-%EC%8B%9C%EC%9E%91",
            "title": "노개북 - 클린코드 시작",
            "summary": "노마드 개발자 북클럽 소개 및 책 구매 인증",
            "content_text": "첫번째 과제 - 책 구매 인증 Photo by thehue클린코드 책 구매 인증합니다!노마드 개발자 북클럽에 가입하게 되었습니다. 개발자의 필독서인 클린코드라는 책을 3주동안 읽고 TIL을 공유하는 학습 프로그램입니다. 최근에 굉장히 읽기 힘든 코드를 유지 보수한적이 있는데, 코드를 수정하면서 기존 코드가 굉장히 잘못 짜여있다는건 알겠는데 어떤 방향으로 수정해야 옳은 것인지에 대해 오랫동안 고민한 적이 있습니다. 클린코드 책이 저에게 좋은 가이드라인이 되길 바랍니다.북클럽을 통해 얻고 싶은 것  글 쓰기 실력  꾸준히 무언가를 하는 습관  공부한 것을 정리하는 습관",
            "content_html": "<h4 id=\"첫번째-과제---책-구매-인증\">첫번째 과제 - 책 구매 인증</h4><p><img src=\"https://user-images.githubusercontent.com/45552388/164722540-7c204312-0f29-4c2c-80a4-cc9e9fd8cdf5.jpeg\" alt=\"클린코드_인증\" /> <em>Photo by thehue</em></p><p>클린코드 책 구매 인증합니다!</p><p>노마드 개발자 북클럽에 가입하게 되었습니다. 개발자의 필독서인 <code class=\"language-plaintext highlighter-rouge\">클린코드</code>라는 책을 3주동안 읽고 TIL을 공유하는 학습 프로그램입니다.<br /> 최근에 굉장히 읽기 힘든 코드를 유지 보수한적이 있는데, 코드를 수정하면서 기존 코드가 굉장히 잘못 짜여있다는건 알겠는데 어떤 방향으로 수정해야 옳은 것인지에 대해 오랫동안 고민한 적이 있습니다. 클린코드 책이 저에게 좋은 가이드라인이 되길 바랍니다.</p><h4 id=\"북클럽을-통해-얻고-싶은-것\">북클럽을 통해 얻고 싶은 것</h4><ul>  <li>글 쓰기 실력</li>  <li>꾸준히 무언가를 하는 습관</li>  <li>공부한 것을 정리하는 습관</li></ul>",
            "url": "https://thehue.github.io/2022/04/22/%EB%85%B8%EA%B0%9C%EB%B6%81-%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C-%EC%8B%9C%EC%9E%91",
            
            
            
            "tags": ["코딩","개발자","노마드북클럽","노개북"],
            
            "date_published": "2022-04-22T00:00:00+09:00",
            "date_modified": "2022-04-22T00:00:00+09:00",
            
                "author":  {
                "name": "thehue",
                "url": null,
                "avatar": null
                }
                
            
        }
    
    ]
}