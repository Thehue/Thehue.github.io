{
    "version": "https://jsonfeed.org/version/1",
    "title": "thehue",
    "home_page_url": "https://thehue.github.io/",
    "feed_url": "https://thehue.github.io/feed.json",
    "description": "Front-end Developer thehue's blog. ",
    "icon": "https://thehue.github.io/apple-touch-icon.png",
    "favicon": "https://thehue.github.io/favicon.ico",
    "expired": false,
    
    "author":  {
        "name": "thehue",
        "url": null,
        "avatar": null
    },
    
"items": [
    
        {
            "id": "https://thehue.github.io/2022/05/04/til-%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C-6%EC%9E%A5-%EA%B0%9D%EC%B2%B4%EC%99%80-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0",
            "title": "TIL 클린코드 - 6장. 객체와 자료 구조",
            "summary": "책 클린코드 6장 형식 객체와 자료 구조 정리 및 느낌",
            "content_text": "TIL (Today I Learned)2022.05.04오늘 읽은 범위6장. 객체와 자료 구조책에서 기억하고 싶은 내용을 써보세요.  변수를 비공개로 정의하는 이유는 남들이 변수에 의존하지 않게 만들고 싶어서다.  자료 추상화          변수를 private으로 선언하더라도 각 값마다 get함수와 set함수를 제공한다면 구현을 외부로 노출하는 셈이다.      변수 사이에 함수라는 계층을 넣는다고 구현이 저절로 감춰지지는 않는다. 구현을 감추려면 추상화가 필요하다. 추상 인터페이스를 제공해 사용자가 구현을 모른 채 자료의 핵심을 조작할 수 있어야 진정한 의미의 클래스이다.      자료를 세세하게 공개하기 보다는 추상적인 개념으로 표현하는 편이 좋다.        자료/객체 비대칭          객체는 추상화 뒤로 자료를 숨긴 채 자료를 다루는 함수만 공개한다.      자료 구조는 자료를 그대로 공개하며 별다른 함수는 제공하지 않는다.      복잡한 시스템을 짜다 보면 새로운 함수가 아니라 새로운 자료 타입이 필요한 경우가 생긴다. 이때는 클래스와 객체 지향 기법이 가장 적합하다.      반면, 새로운 자료 타입이 아니라 새로운 함수가 필요한 경우도 생긴다. 이때는 절차적인 코드와 자료 구조가 좀 더 적합하다.            디미터 법칙          디미터 법칙은 잘 알려진 휴리스틱(직관적으로 판단)으로, 모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다는 법칙이다.      객체에서 허용된 메소드가 반환하는 객체의 메서드는 호출하면 안 된다.        // 나쁜 예 - 기차 충돌(train wreck)final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath();// 좋은 예Options opts = ctxt.getOptions();File scratchDir = opts.getScratchDir();final String ouputDir = scratchDir.getAbsolutePath();/*ctxt, Options, ScratchDir이 객체라면 내부 구조를 숨겨야 하므로 디미터 법칙을 위반하고,자료 구조라면 내부 구조를 노출하므로 디미터 법칙이 적용되지 않는다.*/// 더 좋은 예 - 조회 함수를 이용하지 않음final String outputDir = ctxt.options.scratchDir.absolutePath;                    ctxt가 객체라면 뭔가를 하라고 말해야지 속을 드러내라고 말하면 안 된다.        // 디미터 법칙을 위반하지 않는 좋은 예시BufferedOutputStream bos = ctxt.createScratchFileStream(classFileName);// 내부 구조를 드러내지 않으며 모듈에서 해당 함수는 자신이 몰라야 하는 여러 객체를 탐색할 필요가 없다        자료 전달 객체          자료 구조체의 전형적인 형태는 공개 변수만 있고 함수가 없는 클래스다. 이런 자료 구조체를 때로는 자료 전달 객체(Data Transfer Object, DTO)      데이터베이스와 통신하거나 소켓에서 받은 메시지의 구문을 분석할 때 유용하다.      활성 레코드                  활성 레코드는 DTO의 특수한 형태이다. 공개 변수가 있거나 비공개 변수에 조회/설정 함수가 있는 자료 구조지만, 대개 save나 find와 같은 탐색 함수도 제공한다. 활성 레코드는 데이터베이스 테이블이나 다른 소스에서 자료를 직접 변환한 결과다.                    오늘 읽은 소감은? 떠오르는 생각을 가볍게 적어보세요  예전에 잠깐 spring framework로 백엔드 API를 개발한 경험이 있는데, 객체와 자료 구조의 의미를 제대로 모르고 잡종 구조(절반은 객체, 절반은 자료구조)로 개발했던 것 같다.  자바 코드로 예시를 보여주고 있지만 기차 충돌 예시는 모든 코드에 적용되는 예시인 것 같다.  나는 주로 자바스크립트와 타입스크립트를 사용하기 때문에 [Clean Code concepts adapted for JavaScript - 한글 번역판](https://github.com/qkraudghgh/clean-code-javascript-ko) 을 보고 공부했고 아래 내용은 연관된 내용만 가져온 것이다.객체와 자료구조(Objects and Data Structures)getter와 setter를 사용하세요JavaScript는 인터페이스와 타입을 가지고있지 않고 이러한 패턴을 적용하기가 힘듭니다. 왜냐하면 public이나 private같은 키워드가 없기 때문이죠. 그렇기 때문에 getter 및 setter를 사용하여 객체의 데이터에 접근하는 것이 객체의 속성을 찾는 것보다 훨씬 낫습니다. “왜요?”라고 물으실 수도 있겠습니다. 왜 그런지에 대해서 몇 가지 이유를 두서없이 적어봤습니다.  객체의 속성을 얻는 것 이상의 많은 것을 하고싶을 때, 코드에서 모든 접근자를 찾아 바꾸고 할 필요가 없습니다.  set할때 검증로직을 추가하는 것이 코드를 더 간단하게 만듭니다.  내부용 API를 캡슐화 할 수 있습니다.  getting과 setting할 때 로그를 찾거나 에러처리를 하기 쉽습니다.  서버에서 객체 속성을 받아올 때 lazy load 할 수 있습니다.안좋은 예:function makeBankAccount() {  // ...  return {    // ...    balance: 0,  };}const account = makeBankAccount();account.balance = 100;좋은 예:function makeBankAccount() {  // private으로 선언된 변수  let balance = 0;  // 아래 return을 통해 public으로 선언된 \"getter\"  function getBalance() {    return balance;  }  // 아래 return을 통해 public으로 선언된 \"setter\"  function setBalance(amount) {    // ... balance를 업데이트하기 전 검증로직    balance = amount;  }  return {    // ...    getBalance,    setBalance,  };}const account = makeBankAccount();account.setBalance(100);객체에 비공개 멤버를 만드세요[클로저](https://developer.mozilla.org/ko/docs/Web/JavaScript/Closures)를 이용하면 가능합니다. (ES5 이하에서도)안좋은 예:const Employee = function (name) {  this.name = name;};Employee.prototype.getName = function getName() {  return this.name;};const employee = new Employee('John Doe');console.log(`Employee name: ${employee.getName()}`); // Employee name: John Doedelete employee.name;console.log(`Employee name: ${employee.getName()}`); // Employee name: undefined좋은 예:function makeEmployee(name) {  return {    getName() {      return name;    },  };}const employee = makeEmployee('John Doe');console.log(`Employee name: ${employee.getName()}`); // Employee name: John Doedelete employee.name;console.log(`Employee name: ${employee.getName()}`); // Employee name: John Doe",
            "content_html": "<p><strong>TIL (Today I Learned)</strong></p><p>2022.05.04</p><p><strong>오늘 읽은 범위</strong></p><p>6장. 객체와 자료 구조</p><p><strong>책에서 기억하고 싶은 내용을 써보세요.</strong></p><ul>  <li>변수를 비공개로 정의하는 이유는 남들이 변수에 의존하지 않게 만들고 싶어서다.</li>  <li>자료 추상화    <ul>      <li>변수를 private으로 선언하더라도 각 값마다 get함수와 set함수를 제공한다면 구현을 외부로 노출하는 셈이다.</li>      <li>변수 사이에 함수라는 계층을 넣는다고 구현이 저절로 감춰지지는 않는다. 구현을 감추려면 추상화가 필요하다. 추상 인터페이스를 제공해 사용자가 구현을 모른 채 자료의 핵심을 조작할 수 있어야 진정한 의미의 클래스이다.</li>      <li>자료를 세세하게 공개하기 보다는 추상적인 개념으로 표현하는 편이 좋다.</li>    </ul>  </li>  <li>자료/객체 비대칭    <ul>      <li>객체는 추상화 뒤로 자료를 숨긴 채 자료를 다루는 함수만 공개한다.</li>      <li>자료 구조는 자료를 그대로 공개하며 별다른 함수는 제공하지 않는다.</li>      <li>복잡한 시스템을 짜다 보면 새로운 함수가 아니라 새로운 자료 타입이 필요한 경우가 생긴다. 이때는 클래스와 객체 지향 기법이 가장 적합하다.</li>      <li>반면, 새로운 자료 타입이 아니라 새로운 함수가 필요한 경우도 생긴다. 이때는 절차적인 코드와 자료 구조가 좀 더 적합하다.</li>    </ul>  </li>  <li>    <p>디미터 법칙</p>    <ul>      <li>디미터 법칙은 잘 알려진 휴리스틱(직관적으로 판단)으로, 모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다는 법칙이다.</li>      <li>객체에서 허용된 메소드가 반환하는 객체의 메서드는 호출하면 안 된다.        <div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 나쁜 예 - 기차 충돌(train wreck)</span><span class=\"kd\">final</span> <span class=\"nc\">String</span> <span class=\"n\">outputDir</span> <span class=\"o\">=</span> <span class=\"n\">ctxt</span><span class=\"o\">.</span><span class=\"na\">getOptions</span><span class=\"o\">().</span><span class=\"na\">getScratchDir</span><span class=\"o\">().</span><span class=\"na\">getAbsolutePath</span><span class=\"o\">();</span><span class=\"c1\">// 좋은 예</span><span class=\"nc\">Options</span> <span class=\"n\">opts</span> <span class=\"o\">=</span> <span class=\"n\">ctxt</span><span class=\"o\">.</span><span class=\"na\">getOptions</span><span class=\"o\">();</span><span class=\"nc\">File</span> <span class=\"n\">scratchDir</span> <span class=\"o\">=</span> <span class=\"n\">opts</span><span class=\"o\">.</span><span class=\"na\">getScratchDir</span><span class=\"o\">();</span><span class=\"kd\">final</span> <span class=\"nc\">String</span> <span class=\"n\">ouputDir</span> <span class=\"o\">=</span> <span class=\"n\">scratchDir</span><span class=\"o\">.</span><span class=\"na\">getAbsolutePath</span><span class=\"o\">();</span><span class=\"cm\">/*ctxt, Options, ScratchDir이 객체라면 내부 구조를 숨겨야 하므로 디미터 법칙을 위반하고,자료 구조라면 내부 구조를 노출하므로 디미터 법칙이 적용되지 않는다.*/</span><span class=\"c1\">// 더 좋은 예 - 조회 함수를 이용하지 않음</span><span class=\"kd\">final</span> <span class=\"nc\">String</span> <span class=\"n\">outputDir</span> <span class=\"o\">=</span> <span class=\"n\">ctxt</span><span class=\"o\">.</span><span class=\"na\">options</span><span class=\"o\">.</span><span class=\"na\">scratchDir</span><span class=\"o\">.</span><span class=\"na\">absolutePath</span><span class=\"o\">;</span></code></pre></div>        </div>      </li>      <li>ctxt가 객체라면 뭔가를 하라고 말해야지 속을 드러내라고 말하면 안 된다.</li>    </ul>    <div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 디미터 법칙을 위반하지 않는 좋은 예시</span><span class=\"nc\">BufferedOutputStream</span> <span class=\"n\">bos</span> <span class=\"o\">=</span> <span class=\"n\">ctxt</span><span class=\"o\">.</span><span class=\"na\">createScratchFileStream</span><span class=\"o\">(</span><span class=\"n\">classFileName</span><span class=\"o\">);</span><span class=\"c1\">// 내부 구조를 드러내지 않으며 모듈에서 해당 함수는 자신이 몰라야 하는 여러 객체를 탐색할 필요가 없다</span></code></pre></div>    </div>  </li>  <li>자료 전달 객체    <ul>      <li>자료 구조체의 전형적인 형태는 공개 변수만 있고 함수가 없는 클래스다. 이런 자료 구조체를 때로는 자료 전달 객체(Data Transfer Object, DTO)</li>      <li>데이터베이스와 통신하거나 소켓에서 받은 메시지의 구문을 분석할 때 유용하다.</li>      <li>활성 레코드        <ul>          <li>활성 레코드는 DTO의 특수한 형태이다. 공개 변수가 있거나 비공개 변수에 조회/설정 함수가 있는 자료 구조지만, 대개 save나 find와 같은 탐색 함수도 제공한다. 활성 레코드는 데이터베이스 테이블이나 다른 소스에서 자료를 직접 변환한 결과다.</li>        </ul>      </li>    </ul>  </li></ul><p><strong>오늘 읽은 소감은? 떠오르는 생각을 가볍게 적어보세요</strong></p><ul>  <li>예전에 잠깐 spring framework로 백엔드 API를 개발한 경험이 있는데, 객체와 자료 구조의 의미를 제대로 모르고 잡종 구조(절반은 객체, 절반은 자료구조)로 개발했던 것 같다.</li>  <li>자바 코드로 예시를 보여주고 있지만 기차 충돌 예시는 모든 코드에 적용되는 예시인 것 같다.</li>  <li>나는 주로 자바스크립트와 타입스크립트를 사용하기 때문에 <code class=\"language-plaintext highlighter-rouge\">[Clean Code concepts adapted for JavaScript - 한글 번역판](https://github.com/qkraudghgh/clean-code-javascript-ko)</code> 을 보고 공부했고 아래 내용은 연관된 내용만 가져온 것이다.</li></ul><hr /><h2 id=\"객체와-자료구조objects-and-data-structures\"><strong>객체와 자료구조(Objects and Data Structures)</strong></h2><h3 id=\"getter와-setter를-사용하세요\">getter와 setter를 사용하세요</h3><p>JavaScript는 인터페이스와 타입을 가지고있지 않고 이러한 패턴을 적용하기가 힘듭니다. 왜냐하면 <code class=\"language-plaintext highlighter-rouge\">public</code>이나 <code class=\"language-plaintext highlighter-rouge\">private</code>같은 키워드가 없기 때문이죠. 그렇기 때문에 getter 및 setter를 사용하여 객체의 데이터에 접근하는 것이 객체의 속성을 찾는 것보다 훨씬 낫습니다. “왜요?”라고 물으실 수도 있겠습니다. 왜 그런지에 대해서 몇 가지 이유를 두서없이 적어봤습니다.</p><ul>  <li>객체의 속성을 얻는 것 이상의 많은 것을 하고싶을 때, 코드에서 모든 <a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions/get\"><code class=\"language-plaintext highlighter-rouge\">접근자</code></a>를 찾아 바꾸고 할 필요가 없습니다.</li>  <li><code class=\"language-plaintext highlighter-rouge\">set</code>할때 검증로직을 추가하는 것이 코드를 더 간단하게 만듭니다.</li>  <li>내부용 API를 캡슐화 할 수 있습니다.</li>  <li><code class=\"language-plaintext highlighter-rouge\">getting</code>과 <code class=\"language-plaintext highlighter-rouge\">setting</code>할 때 로그를 찾거나 에러처리를 하기 쉽습니다.</li>  <li>서버에서 객체 속성을 받아올 때 lazy load 할 수 있습니다.</li></ul><p><strong>안좋은 예:</strong></p><div class=\"language-jsx highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">function</span> <span class=\"nx\">makeBankAccount</span><span class=\"p\">()</span> <span class=\"p\">{</span>  <span class=\"c1\">// ...</span>  <span class=\"k\">return</span> <span class=\"p\">{</span>    <span class=\"c1\">// ...</span>    <span class=\"na\">balance</span><span class=\"p\">:</span> <span class=\"mi\">0</span><span class=\"p\">,</span>  <span class=\"p\">};</span><span class=\"p\">}</span><span class=\"kd\">const</span> <span class=\"nx\">account</span> <span class=\"o\">=</span> <span class=\"nx\">makeBankAccount</span><span class=\"p\">();</span><span class=\"nx\">account</span><span class=\"p\">.</span><span class=\"nx\">balance</span> <span class=\"o\">=</span> <span class=\"mi\">100</span><span class=\"p\">;</span></code></pre></div></div><p><strong>좋은 예:</strong></p><div class=\"language-jsx highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">function</span> <span class=\"nx\">makeBankAccount</span><span class=\"p\">()</span> <span class=\"p\">{</span>  <span class=\"c1\">// private으로 선언된 변수</span>  <span class=\"kd\">let</span> <span class=\"nx\">balance</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>  <span class=\"c1\">// 아래 return을 통해 public으로 선언된 \"getter\"</span>  <span class=\"kd\">function</span> <span class=\"nx\">getBalance</span><span class=\"p\">()</span> <span class=\"p\">{</span>    <span class=\"k\">return</span> <span class=\"nx\">balance</span><span class=\"p\">;</span>  <span class=\"p\">}</span>  <span class=\"c1\">// 아래 return을 통해 public으로 선언된 \"setter\"</span>  <span class=\"kd\">function</span> <span class=\"nx\">setBalance</span><span class=\"p\">(</span><span class=\"nx\">amount</span><span class=\"p\">)</span> <span class=\"p\">{</span>    <span class=\"c1\">// ... balance를 업데이트하기 전 검증로직</span>    <span class=\"nx\">balance</span> <span class=\"o\">=</span> <span class=\"nx\">amount</span><span class=\"p\">;</span>  <span class=\"p\">}</span>  <span class=\"k\">return</span> <span class=\"p\">{</span>    <span class=\"c1\">// ...</span>    <span class=\"nx\">getBalance</span><span class=\"p\">,</span>    <span class=\"nx\">setBalance</span><span class=\"p\">,</span>  <span class=\"p\">};</span><span class=\"p\">}</span><span class=\"kd\">const</span> <span class=\"nx\">account</span> <span class=\"o\">=</span> <span class=\"nx\">makeBankAccount</span><span class=\"p\">();</span><span class=\"nx\">account</span><span class=\"p\">.</span><span class=\"nx\">setBalance</span><span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">);</span></code></pre></div></div><h3 id=\"객체에-비공개-멤버를-만드세요\">객체에 비공개 멤버를 만드세요</h3><p><code class=\"language-plaintext highlighter-rouge\">[클로저](https://developer.mozilla.org/ko/docs/Web/JavaScript/Closures)</code>를 이용하면 가능합니다. (ES5 이하에서도)</p><p><strong>안좋은 예:</strong></p><div class=\"language-jsx highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">const</span> <span class=\"nx\">Employee</span> <span class=\"o\">=</span> <span class=\"kd\">function</span> <span class=\"p\">(</span><span class=\"nx\">name</span><span class=\"p\">)</span> <span class=\"p\">{</span>  <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">name</span> <span class=\"o\">=</span> <span class=\"nx\">name</span><span class=\"p\">;</span><span class=\"p\">};</span><span class=\"nx\">Employee</span><span class=\"p\">.</span><span class=\"nx\">prototype</span><span class=\"p\">.</span><span class=\"nx\">getName</span> <span class=\"o\">=</span> <span class=\"kd\">function</span> <span class=\"nx\">getName</span><span class=\"p\">()</span> <span class=\"p\">{</span>  <span class=\"k\">return</span> <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">name</span><span class=\"p\">;</span><span class=\"p\">};</span><span class=\"kd\">const</span> <span class=\"nx\">employee</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">Employee</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">John Doe</span><span class=\"dl\">'</span><span class=\"p\">);</span><span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s2\">`Employee name: </span><span class=\"p\">${</span><span class=\"nx\">employee</span><span class=\"p\">.</span><span class=\"nx\">getName</span><span class=\"p\">()}</span><span class=\"s2\">`</span><span class=\"p\">);</span> <span class=\"c1\">// Employee name: John Doe</span><span class=\"k\">delete</span> <span class=\"nx\">employee</span><span class=\"p\">.</span><span class=\"nx\">name</span><span class=\"p\">;</span><span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s2\">`Employee name: </span><span class=\"p\">${</span><span class=\"nx\">employee</span><span class=\"p\">.</span><span class=\"nx\">getName</span><span class=\"p\">()}</span><span class=\"s2\">`</span><span class=\"p\">);</span> <span class=\"c1\">// Employee name: undefined</span></code></pre></div></div><p><strong>좋은 예:</strong></p><div class=\"language-jsx highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">function</span> <span class=\"nx\">makeEmployee</span><span class=\"p\">(</span><span class=\"nx\">name</span><span class=\"p\">)</span> <span class=\"p\">{</span>  <span class=\"k\">return</span> <span class=\"p\">{</span>    <span class=\"nx\">getName</span><span class=\"p\">()</span> <span class=\"p\">{</span>      <span class=\"k\">return</span> <span class=\"nx\">name</span><span class=\"p\">;</span>    <span class=\"p\">},</span>  <span class=\"p\">};</span><span class=\"p\">}</span><span class=\"kd\">const</span> <span class=\"nx\">employee</span> <span class=\"o\">=</span> <span class=\"nx\">makeEmployee</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">John Doe</span><span class=\"dl\">'</span><span class=\"p\">);</span><span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s2\">`Employee name: </span><span class=\"p\">${</span><span class=\"nx\">employee</span><span class=\"p\">.</span><span class=\"nx\">getName</span><span class=\"p\">()}</span><span class=\"s2\">`</span><span class=\"p\">);</span> <span class=\"c1\">// Employee name: John Doe</span><span class=\"k\">delete</span> <span class=\"nx\">employee</span><span class=\"p\">.</span><span class=\"nx\">name</span><span class=\"p\">;</span><span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s2\">`Employee name: </span><span class=\"p\">${</span><span class=\"nx\">employee</span><span class=\"p\">.</span><span class=\"nx\">getName</span><span class=\"p\">()}</span><span class=\"s2\">`</span><span class=\"p\">);</span> <span class=\"c1\">// Employee name: John Doe</span></code></pre></div></div>",
            "url": "https://thehue.github.io/2022/05/04/til-%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C-6%EC%9E%A5-%EA%B0%9D%EC%B2%B4%EC%99%80-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0",
            
            
            
            "tags": ["노마드코더","북클럽","노개북","노마드북클럽","코딩","개발자"],
            
            "date_published": "2022-05-04T00:00:00+09:00",
            "date_modified": "2022-05-04T00:00:00+09:00",
            
                "author":  {
                "name": "thehue",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://thehue.github.io/2022/05/02/til-%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C-5%EC%9E%A5-%ED%98%95%EC%8B%9D",
            "title": "TIL 클린코드 - 5장. 형식 맞추기",
            "summary": "책 클린코드 5장 형식 맞추기 정리 및 느낌",
            "content_text": "TIL (Today I Learned)2022.05.02오늘 읽은 범위5장. 형식 맞추기책에서 기억하고 싶은 내용을 써보세요.  형식을 맞추는 목적          코드 형식은 의사소통의 일환이다. 의사소통은 전문 개발자의 일차적인 의무이다.      오랜 시간이 지나 원래 코드의 흔적을 더 이상 찾아보기 어려울 정도로 코드가 바뀌어도 맨 처음 잡아 놓은 구현 스타일과 가독성 수준은 유지보수 용이성과 확장성에 계속 영향을 미친다.        신문 기사처럼 작성하라          소스파일의 이름은 이름만 보고도 올바른 모듈을 살펴보고 있는지 아닌지를 판단할 정도로 신경 써서 짓는다.      소스파일 첫 부분은 고차원 개념과 알고리즘을 설명한다. 아래로 내려갈수록 의도를 세세하게 묘사한다.      마지막에는 가장 저차원 함수와 세부 내역이 나온다.        개념은 빈 행으로 분리하라          빈 행은 새로운 개념을 시작한다는 시각적 단서다.        세로 밀집도          세로 밀집도는 연관성을 의미한다. 서로 밀접한 코드 행은 세로로 가까이 놓여야 한다는 뜻이다.        수직 거리          같은 파일에 속할 정도로 밀접한 두 개념은 세로 거리로 연관성을 표현한다.        변수 선언          변수는 사용하는 위치에 최대한 가까이 선언한다. 지역 변수는 각 함수 맨 처음에 선언한다.      루프를 제어하는 변수는 루프 문 내부에 선언한다.      아주 드물지만 다소 긴 함수에서 블록 상단이나 루프 직전에 변수를 선언하는 사례도 있다.        인스턴스 변수          인스턴스 변수는 클래스 맨 처음에 선언한다. 변수 간에 세로로 거리를 두지 않는다. 잘 설계한 클래스는 많은 클래스 메서드가 인스턴트 변수를 사용하기 때문이다.        종속 변수          한 함수가 다른 함수를 호출한다면 두 함수는 세로로 가까이 배치한다. 또한 가능하다면 호출하는 함수를 호출되는 함수보다 먼저 배치한다.        세로 순서          호출되는 함수를 호출하는 함수보다 나중에 배치한다. 그러면 소스 코드 모듈이 고차원에서 저차원으로 자연스럽게 내려간다.      오늘 읽은 소감은? 떠오르는 생각을 가볍게 적어보세요  책의 형식을 지키지 않은 예시를 보면서 코드 형식을 지키는 것이 가독성에 많은 영향을 끼친다는 것을 더 체감할 수 있었다.  javascript 개발의 경우 prettier로 자동 formatting을 해주는데 오늘 다양한 예제를 보면서 prettier를 개발한 개발자에게 감사함을 느꼈다.🙏🏻  책에서 특히 공감 됐던 구절은 ‘팀에 속한다면 자신이 선호해야 할 규칙은 바로 팀 규칙이다’ 이다. 전에 있었던 회사의 개발자 분이 코드를 리뷰 해주시면서 전체 코드가 마치 한 사람이 작성한 것처럼 코드를 작성해야한다고 말씀해주셨던 기억이 난다.궁금한 내용이 있거나, 잘 이해되지 않는 내용이 있다면 적어보세요.  일반적으로 C++ 에서는 모든 인스턴스 변수를 클래스 마지막에 선언한다는 소위 가위 규칙을 적용한다.          가위 규칙 어렵다..🥲      ",
            "content_html": "<p><strong>TIL (Today I Learned)</strong></p><p>2022.05.02</p><p><strong>오늘 읽은 범위</strong></p><p>5장. 형식 맞추기</p><p><strong>책에서 기억하고 싶은 내용을 써보세요.</strong></p><ul>  <li><strong>형식을 맞추는 목적</strong>    <ul>      <li>코드 형식은 의사소통의 일환이다. 의사소통은 전문 개발자의 일차적인 의무이다.</li>      <li>오랜 시간이 지나 원래 코드의 흔적을 더 이상 찾아보기 어려울 정도로 코드가 바뀌어도 맨 처음 잡아 놓은 구현 스타일과 가독성 수준은 유지보수 용이성과 확장성에 계속 영향을 미친다.</li>    </ul>  </li>  <li><strong>신문 기사처럼 작성하라</strong>    <ul>      <li>소스파일의 이름은 이름만 보고도 올바른 모듈을 살펴보고 있는지 아닌지를 판단할 정도로 신경 써서 짓는다.</li>      <li>소스파일 첫 부분은 <a href=\"https://developer-talk.tistory.com/162\">고차원 개념</a>과 알고리즘을 설명한다. 아래로 내려갈수록 의도를 세세하게 묘사한다.</li>      <li>마지막에는 가장 저차원 함수와 세부 내역이 나온다.</li>    </ul>  </li>  <li><strong>개념은 빈 행으로 분리하라</strong>    <ul>      <li>빈 행은 새로운 개념을 시작한다는 시각적 단서다.</li>    </ul>  </li>  <li><strong>세로 밀집도</strong>    <ul>      <li>세로 밀집도는 연관성을 의미한다. 서로 밀접한 코드 행은 세로로 가까이 놓여야 한다는 뜻이다.</li>    </ul>  </li>  <li><strong>수직 거리</strong>    <ul>      <li>같은 파일에 속할 정도로 밀접한 두 개념은 세로 거리로 연관성을 표현한다.</li>    </ul>  </li>  <li><strong>변수 선언</strong>    <ul>      <li>변수는 사용하는 위치에 최대한 가까이 선언한다. 지역 변수는 각 함수 맨 처음에 선언한다.</li>      <li>루프를 제어하는 변수는 루프 문 내부에 선언한다.</li>      <li>아주 드물지만 다소 긴 함수에서 블록 상단이나 루프 직전에 변수를 선언하는 사례도 있다.</li>    </ul>  </li>  <li><strong>인스턴스 변수</strong>    <ul>      <li><a href=\"https://ko.wikipedia.org/wiki/%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4_%EB%B3%80%EC%88%98\">인스턴스 변수</a>는 클래스 맨 처음에 선언한다. 변수 간에 세로로 거리를 두지 않는다. 잘 설계한 클래스는 많은 클래스 메서드가 인스턴트 변수를 사용하기 때문이다.</li>    </ul>  </li>  <li><strong>종속 변수</strong>    <ul>      <li>한 함수가 다른 함수를 호출한다면 두 함수는 세로로 가까이 배치한다. 또한 가능하다면 호출하는 함수를 호출되는 함수보다 먼저 배치한다.</li>    </ul>  </li>  <li><strong>세로 순서</strong>    <ul>      <li>호출되는 함수를 호출하는 함수보다 나중에 배치한다. 그러면 소스 코드 모듈이 고차원에서 저차원으로 자연스럽게 내려간다.</li>    </ul>  </li></ul><p><strong>오늘 읽은 소감은? 떠오르는 생각을 가볍게 적어보세요</strong></p><ul>  <li>책의 형식을 지키지 않은 예시를 보면서 코드 형식을 지키는 것이 가독성에 많은 영향을 끼친다는 것을 더 체감할 수 있었다.</li>  <li>javascript 개발의 경우 prettier로 자동 formatting을 해주는데 오늘 다양한 예제를 보면서 prettier를 개발한 개발자에게 감사함을 느꼈다.🙏🏻</li>  <li>책에서 특히 공감 됐던 구절은 <em>‘팀에 속한다면 자신이 선호해야 할 규칙은 바로 팀 규칙이다’</em> 이다. 전에 있었던 회사의 개발자 분이 코드를 리뷰 해주시면서 전체 코드가 마치 한 사람이 작성한 것처럼 코드를 작성해야한다고 말씀해주셨던 기억이 난다.</li></ul><p><strong>궁금한 내용이 있거나, 잘 이해되지 않는 내용이 있다면 적어보세요.</strong></p><ul>  <li>일반적으로 C++ 에서는 모든 인스턴스 변수를 클래스 마지막에 선언한다는 소위 가위 규칙을 적용한다.    <ul>      <li>가위 규칙 어렵다..🥲</li>    </ul>  </li></ul>",
            "url": "https://thehue.github.io/2022/05/02/til-%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C-5%EC%9E%A5-%ED%98%95%EC%8B%9D",
            
            
            
            "tags": ["노마드코더","북클럽","노개북","노마드북클럽","코딩","개발자"],
            
            "date_published": "2022-05-02T00:00:00+09:00",
            "date_modified": "2022-05-02T00:00:00+09:00",
            
                "author":  {
                "name": "thehue",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://thehue.github.io/2022/04/29/til-%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C-4%EC%9E%A5-%EC%A3%BC%EC%84%9D",
            "title": "TIL 클린코드 - 4장. 주석",
            "summary": "책 클린코드 4장 주석",
            "content_text": "TIL (Today I Learned)2022.04.29오늘 읽은 범위4장. 주석책에서 기억하고 싶은 내용을 써보세요.  주석은 언제나 실패를 의미한다. 때때로 주석 없이는 자신을 표현할 방법을 찾지 못해 할 수 없이 주석을 사용한다. 코드로 의도를 표현할 방법은 없을까?(p.68)  표현력이 풍부하고 깔끔하며 주석이 거의 없는 코드가, 복잡하고 어수선하며 주석이 많이 달린 코드보다 훨신 좋다. 자신이 저지른 난장판을 주석으로 설명하려 애쓰는 대신에 그 난장판을 깨끗이 치우는 데 시간을 보내라!(p.69)      다음 코드 예제 두 개를 살펴보자. 어느 쪽이 더 나은가? (p.70)    // 직원에게 복지 혜택을 받을 자격이 있는지 검사한다.if ((employee.flags &amp; HOURLY_FLAG) &amp;&amp; (employee.age &gt; 65))        다음 코드는 어떤가?    if (employee.isEligibleForFullBenefits())        법적인 주석 - 각 소스 파일 첫머리에 주석으로 들어가는 저작권 정보와 소유권 정보는 필요하고도 타당하다. (p.70)  정보를 제공하는 주석 - 함수 이름에 정보를 담는 편이 좋다.  의도를 설명하는 주석 - 때때로 주석은 구현을 이해하게 도와주는 선을 넘어 결정에 깔린 의도까지 설명한다.  의미를 명료하게 밝히는 주석 - 일반적으로는 인수나 반환값 자체를 명확하게 만들면 더 좋겠지만, 인수나 반환값이 표준 라이브러리나 변경하지 못하는 코드에 속한다면 의미를 명료하게 밝히는 주석이 유용하다.  결과를 경고하는 주석 - ex) 특정 테스트 케이스를 꺼야 하는 이유를 설명하는 주석// 여유 시간이 충분하지 않다면 실행하지 마십시오.public void _testWithReallyBigFile(){\twriteLinesToFile(1000000);\t...}public static SimpleDateFormat makeStandardHttpDateFormat(){\t// SimpleDateFormat은 스레드에 안전하지 못하다.\t// 따라서 각 인스턴스를 독립적으로 생성해야 한다.\tSimpleDateFormat df = new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss z\");\tdf.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\treturn df;}  TODO 주석 - ‘앞으로 할 일’을 // TODO 주석으로 남겨두면 편하다.// TODO-MdM 현재 필요하지 않다.// 체크아웃 모델을 도입하면 함수가 필요 없다.protected VersionInfo makeVersion() throws Exception{\treturn null;}  중요성을 강조하는 주석String listItemContent = match.group(3).trim();// 여기서 trim은 정말 중요하다. trim 함수는 문자열에서 시작 공백을 제거한다.// 문자열에 시작 공백이 있으면 다른 문자열로 인식되기 때문이다.  주절거리는 주석 - 특별한 이유 없이 의무감으로 혹은 프로세스에서 하라고 하니까 마지못해 주석을 단다면 전적으로 시간낭비다. 주석을 달기로 결정했다면 충분한 시간을 들여 최고의 주석을 달도록 한다.  의무적으로 다는 주석 - 모든 함수에 Javadocs를 달거나 모든 변수에 주석을 달아야 한다는 규칙은 어리석기 그지없다.  함수나 변수로 표현할 수 있다면 주석을 달지 마라  닫는 괄호에 다는 주석 - 닫는 괄호에 주석을 달아야겠다는 생각이 든다면 대신에 함수를 줄이려 시도하자.  공로를 돌리거나 저자를 표시하는 주석 - 소스 코드 관리 시스템은 누가 언제 무엇을 추가했는지 귀신처럼 기억한다. 저자 이름으로 코드를 오염시킬 필요가 없다.  주석으로 처리한 코드 - 주석으로 처리된 코드는 다른 사람들이 지우기를 주저한다. 그래서 질 나쁜 와인병 바닥에 앙금이 쌓이듯 쓸모 없는 코드가 점차 쌓여간다.  전역 정보 - 주석을 달아야 한다면 근처에 있는 코드만 기술하라. 함수 자체는 포트 기본값을 전혀 통제하지 못한다. 즉, 포트 기본값을 설정하는 코드가 변해도 아래 주석이 변하리라는 보장은 전혀 없다./*** 적합성 테스트가 동작하는 포트: 기본값은 &lt;b&gt;8082&lt;/b&gt;** @param fitnessPort*/public void setFitnessPort(int fitnessPort){\tthis.fitnessePort = fitnessePort;}오늘 읽은 소감은? 떠오르는 생각을 가볍게 적어보세요  이번 장을 읽으면서 얼마나 찔렸는지 모른다. 가장 찔렸던 부분은 의무적으로 다는 주석과 중복되는 주석! 혹시나 내 코드를 이해하지 못할까봐 의무적으로 달았던 주석이 많았는데 저자의 말이 맞는 것 같다. 이해할 수 없게 코드를 짰기 때문에 주석을 다는 것이라고!  주석을 어떻게 달까 고민하는 시간도 많았는데 주석이 필요 없는 방향으로 변수명과 함수명을 짓는데 더 많은 시간을 쏟아야겠다.  보통 글을 작성할 때 여러번 다듬고 이 말을 여기에 써도 되는가를 고민하게 된다. 왜냐면 남들이 읽기 때문이다! 코드나 주석을 작성하는 것도 결국은 기록이 남고 남들이 읽는데 왜 신중하지 않게 작성했지?라는 생각이 든다. 주석 하나도 고민하면서 남기자.궁금한 내용이 있거나, 잘 이해되지 않는 내용이 있다면 적어보세요.  이번 장은 이해가 잘됐다! 😁",
            "content_html": "<p><strong>TIL (Today I Learned)</strong></p><p>2022.04.29</p><p><strong>오늘 읽은 범위</strong></p><p>4장. 주석</p><p><strong>책에서 기억하고 싶은 내용을 써보세요.</strong></p><ul>  <li>주석은 언제나 실패를 의미한다. 때때로 주석 없이는 자신을 표현할 방법을 찾지 못해 할 수 없이 주석을 사용한다. 코드로 의도를 표현할 방법은 없을까?(p.68)</li>  <li>표현력이 풍부하고 깔끔하며 주석이 거의 없는 코드가, 복잡하고 어수선하며 주석이 많이 달린 코드보다 훨신 좋다. 자신이 저지른 난장판을 주석으로 설명하려 애쓰는 대신에 그 난장판을 깨끗이 치우는 데 시간을 보내라!(p.69)</li>  <li>    <p>다음 코드 예제 두 개를 살펴보자. 어느 쪽이 더 나은가? (p.70)</p>    <div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 직원에게 복지 혜택을 받을 자격이 있는지 검사한다.</span><span class=\"k\">if</span> <span class=\"o\">((</span><span class=\"n\">employee</span><span class=\"o\">.</span><span class=\"na\">flags</span> <span class=\"o\">&amp;</span> <span class=\"no\">HOURLY_FLAG</span><span class=\"o\">)</span> <span class=\"o\">&amp;&amp;</span> <span class=\"o\">(</span><span class=\"n\">employee</span><span class=\"o\">.</span><span class=\"na\">age</span> <span class=\"o\">&gt;</span> <span class=\"mi\">65</span><span class=\"o\">))</span></code></pre></div>    </div>    <p>다음 코드는 어떤가?</p>    <div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">employee</span><span class=\"o\">.</span><span class=\"na\">isEligibleForFullBenefits</span><span class=\"o\">())</span></code></pre></div>    </div>  </li>  <li>법적인 주석 - 각 소스 파일 첫머리에 주석으로 들어가는 저작권 정보와 소유권 정보는 필요하고도 타당하다. (p.70)</li>  <li>정보를 제공하는 주석 - 함수 이름에 정보를 담는 편이 좋다.</li>  <li>의도를 설명하는 주석 - 때때로 주석은 구현을 이해하게 도와주는 선을 넘어 결정에 깔린 의도까지 설명한다.</li>  <li>의미를 명료하게 밝히는 주석 - 일반적으로는 인수나 반환값 자체를 명확하게 만들면 더 좋겠지만, 인수나 반환값이 표준 라이브러리나 변경하지 못하는 코드에 속한다면 의미를 명료하게 밝히는 주석이 유용하다.</li>  <li>결과를 경고하는 주석 - ex) 특정 테스트 케이스를 꺼야 하는 이유를 설명하는 주석</li></ul><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 여유 시간이 충분하지 않다면 실행하지 마십시오.</span><span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">_testWithReallyBigFile</span><span class=\"o\">()</span><span class=\"o\">{</span>\t<span class=\"n\">writeLinesToFile</span><span class=\"o\">(</span><span class=\"mi\">1000000</span><span class=\"o\">);</span>\t<span class=\"o\">...</span><span class=\"o\">}</span><span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"nc\">SimpleDateFormat</span> <span class=\"nf\">makeStandardHttpDateFormat</span><span class=\"o\">()</span><span class=\"o\">{</span>\t<span class=\"c1\">// SimpleDateFormat은 스레드에 안전하지 못하다.</span>\t<span class=\"c1\">// 따라서 각 인스턴스를 독립적으로 생성해야 한다.</span>\t<span class=\"nc\">SimpleDateFormat</span> <span class=\"n\">df</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">SimpleDateFormat</span><span class=\"o\">(</span><span class=\"s\">\"EEE, dd MMM yyyy HH:mm:ss z\"</span><span class=\"o\">);</span>\t<span class=\"n\">df</span><span class=\"o\">.</span><span class=\"na\">setTimeZone</span><span class=\"o\">(</span><span class=\"nc\">TimeZone</span><span class=\"o\">.</span><span class=\"na\">getTimeZone</span><span class=\"o\">(</span><span class=\"s\">\"GMT\"</span><span class=\"o\">));</span>\t<span class=\"k\">return</span> <span class=\"n\">df</span><span class=\"o\">;</span><span class=\"o\">}</span></code></pre></div></div><ul>  <li>TODO 주석 - ‘앞으로 할 일’을 // TODO 주석으로 남겨두면 편하다.</li></ul><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// TODO-MdM 현재 필요하지 않다.</span><span class=\"c1\">// 체크아웃 모델을 도입하면 함수가 필요 없다.</span><span class=\"kd\">protected</span> <span class=\"nc\">VersionInfo</span> <span class=\"nf\">makeVersion</span><span class=\"o\">()</span> <span class=\"kd\">throws</span> <span class=\"nc\">Exception</span><span class=\"o\">{</span>\t<span class=\"k\">return</span> <span class=\"kc\">null</span><span class=\"o\">;</span><span class=\"o\">}</span></code></pre></div></div><ul>  <li>중요성을 강조하는 주석</li></ul><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">String</span> <span class=\"n\">listItemContent</span> <span class=\"o\">=</span> <span class=\"n\">match</span><span class=\"o\">.</span><span class=\"na\">group</span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">).</span><span class=\"na\">trim</span><span class=\"o\">();</span><span class=\"c1\">// 여기서 trim은 정말 중요하다. trim 함수는 문자열에서 시작 공백을 제거한다.</span><span class=\"c1\">// 문자열에 시작 공백이 있으면 다른 문자열로 인식되기 때문이다.</span></code></pre></div></div><ul>  <li>주절거리는 주석 - 특별한 이유 없이 의무감으로 혹은 프로세스에서 하라고 하니까 마지못해 주석을 단다면 전적으로 시간낭비다. 주석을 달기로 결정했다면 충분한 시간을 들여 최고의 주석을 달도록 한다.</li>  <li>의무적으로 다는 주석 - 모든 함수에 Javadocs를 달거나 모든 변수에 주석을 달아야 한다는 규칙은 어리석기 그지없다.</li>  <li>함수나 변수로 표현할 수 있다면 주석을 달지 마라</li>  <li>닫는 괄호에 다는 주석 - 닫는 괄호에 주석을 달아야겠다는 생각이 든다면 대신에 함수를 줄이려 시도하자.</li>  <li>공로를 돌리거나 저자를 표시하는 주석 - 소스 코드 관리 시스템은 누가 언제 무엇을 추가했는지 귀신처럼 기억한다. 저자 이름으로 코드를 오염시킬 필요가 없다.</li>  <li>주석으로 처리한 코드 - 주석으로 처리된 코드는 다른 사람들이 지우기를 주저한다. 그래서 질 나쁜 와인병 바닥에 앙금이 쌓이듯 쓸모 없는 코드가 점차 쌓여간다.</li>  <li>전역 정보 - 주석을 달아야 한다면 근처에 있는 코드만 기술하라. 함수 자체는 포트 기본값을 전혀 통제하지 못한다. 즉, 포트 기본값을 설정하는 코드가 변해도 아래 주석이 변하리라는 보장은 전혀 없다.</li></ul><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"cm\">/*** 적합성 테스트가 동작하는 포트: 기본값은 &lt;b&gt;8082&lt;/b&gt;** @param fitnessPort*/</span><span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">setFitnessPort</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">fitnessPort</span><span class=\"o\">){</span>\t<span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">fitnessePort</span> <span class=\"o\">=</span> <span class=\"n\">fitnessePort</span><span class=\"o\">;</span><span class=\"o\">}</span></code></pre></div></div><p><strong>오늘 읽은 소감은? 떠오르는 생각을 가볍게 적어보세요</strong></p><ul>  <li>이번 장을 읽으면서 얼마나 찔렸는지 모른다. 가장 찔렸던 부분은 의무적으로 다는 주석과 중복되는 주석! 혹시나 내 코드를 이해하지 못할까봐 의무적으로 달았던 주석이 많았는데 저자의 말이 맞는 것 같다. 이해할 수 없게 코드를 짰기 때문에 주석을 다는 것이라고!</li>  <li>주석을 어떻게 달까 고민하는 시간도 많았는데 주석이 필요 없는 방향으로 변수명과 함수명을 짓는데 더 많은 시간을 쏟아야겠다.</li>  <li>보통 글을 작성할 때 여러번 다듬고 이 말을 여기에 써도 되는가를 고민하게 된다. 왜냐면 남들이 읽기 때문이다! 코드나 주석을 작성하는 것도 결국은 기록이 남고 남들이 읽는데 왜 신중하지 않게 작성했지?라는 생각이 든다. 주석 하나도 고민하면서 남기자.</li></ul><p><strong>궁금한 내용이 있거나, 잘 이해되지 않는 내용이 있다면 적어보세요.</strong></p><ul>  <li>이번 장은 이해가 잘됐다! 😁</li></ul>",
            "url": "https://thehue.github.io/2022/04/29/til-%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C-4%EC%9E%A5-%EC%A3%BC%EC%84%9D",
            
            
            
            "tags": ["노마드코더","북클럽","노개북","노마드북클럽","코딩","개발자"],
            
            "date_published": "2022-04-29T00:00:00+09:00",
            "date_modified": "2022-04-29T00:00:00+09:00",
            
                "author":  {
                "name": "thehue",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://thehue.github.io/2022/04/22/%EB%85%B8%EA%B0%9C%EB%B6%81-%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C-%EC%8B%9C%EC%9E%91",
            "title": "노개북 - 클린코드 시작",
            "summary": "노마드 개발자 북클럽 소개 및 책 구매 인증",
            "content_text": "첫번째 과제 - 책 구매 인증 Photo by thehue클린코드 책 구매 인증합니다!노마드 개발자 북클럽에 가입하게 되었습니다. 개발자의 필독서인 클린코드라는 책을 3주동안 읽고 TIL을 공유하는 학습 프로그램입니다. 최근에 굉장히 읽기 힘든 코드를 유지 보수한적이 있는데, 코드를 수정하면서 기존 코드가 굉장히 잘못 짜여있다는건 알겠는데 어떤 방향으로 수정해야 옳은 것인지에 대해 오랫동안 고민한 적이 있습니다. 클린코드 책이 저에게 좋은 가이드라인이 되길 바랍니다.북클럽을 통해 얻고 싶은 것  글 쓰기 실력  꾸준히 무언가를 하는 습관  공부한 것을 정리하는 습관",
            "content_html": "<h4 id=\"첫번째-과제---책-구매-인증\">첫번째 과제 - 책 구매 인증</h4><p><img src=\"https://user-images.githubusercontent.com/45552388/164722540-7c204312-0f29-4c2c-80a4-cc9e9fd8cdf5.jpeg\" alt=\"클린코드_인증\" /> <em>Photo by thehue</em></p><p>클린코드 책 구매 인증합니다!</p><p>노마드 개발자 북클럽에 가입하게 되었습니다. 개발자의 필독서인 <code class=\"language-plaintext highlighter-rouge\">클린코드</code>라는 책을 3주동안 읽고 TIL을 공유하는 학습 프로그램입니다.<br /> 최근에 굉장히 읽기 힘든 코드를 유지 보수한적이 있는데, 코드를 수정하면서 기존 코드가 굉장히 잘못 짜여있다는건 알겠는데 어떤 방향으로 수정해야 옳은 것인지에 대해 오랫동안 고민한 적이 있습니다. 클린코드 책이 저에게 좋은 가이드라인이 되길 바랍니다.</p><h4 id=\"북클럽을-통해-얻고-싶은-것\">북클럽을 통해 얻고 싶은 것</h4><ul>  <li>글 쓰기 실력</li>  <li>꾸준히 무언가를 하는 습관</li>  <li>공부한 것을 정리하는 습관</li></ul>",
            "url": "https://thehue.github.io/2022/04/22/%EB%85%B8%EA%B0%9C%EB%B6%81-%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C-%EC%8B%9C%EC%9E%91",
            
            
            
            "tags": ["코딩","개발자","노마드북클럽","노개북"],
            
            "date_published": "2022-04-22T00:00:00+09:00",
            "date_modified": "2022-04-22T00:00:00+09:00",
            
                "author":  {
                "name": "thehue",
                "url": null,
                "avatar": null
                }
                
            
        }
    
    ]
}